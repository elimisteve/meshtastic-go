// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.26.0
// 	protoc        v3.15.6
// source: mesh.proto

package meshtastic_go

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

//
// A failure in delivering a message (usually used for routing control messages,
//  but might be provided in addition to ack.fail_id to provide
// details on the type of failure).
type ErrorReason int32

const (
	// This message is not a failure
	ErrorReason_NONE ErrorReason = 0
	//
	// Our node doesn't have a route to the requested destination anymore.
	ErrorReason_NO_ROUTE ErrorReason = 1
	//
	// We received a nak while trying to forward on your behalf
	ErrorReason_GOT_NAK ErrorReason = 2
	ErrorReason_TIMEOUT ErrorReason = 3
	// No suitable interface could be found for delivering this packet
	ErrorReason_NO_INTERFACE ErrorReason = 4
	// We reached the max retransmission count (typically for naive flood routing)
	ErrorReason_MAX_RETRANSMIT ErrorReason = 5
)

// Enum value maps for ErrorReason.
var (
	ErrorReason_name = map[int32]string{
		0: "NONE",
		1: "NO_ROUTE",
		2: "GOT_NAK",
		3: "TIMEOUT",
		4: "NO_INTERFACE",
		5: "MAX_RETRANSMIT",
	}
	ErrorReason_value = map[string]int32{
		"NONE":           0,
		"NO_ROUTE":       1,
		"GOT_NAK":        2,
		"TIMEOUT":        3,
		"NO_INTERFACE":   4,
		"MAX_RETRANSMIT": 5,
	}
)

func (x ErrorReason) Enum() *ErrorReason {
	p := new(ErrorReason)
	*p = x
	return p
}

func (x ErrorReason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ErrorReason) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[0].Descriptor()
}

func (ErrorReason) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[0]
}

func (x ErrorReason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ErrorReason.Descriptor instead.
func (ErrorReason) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{0}
}

//
// Shared constants between device and phone
type Constants int32

const (
	//
	// First enum must be zero, and we are just using this enum to
	// pass int constants between two very different environments
	Constants_Unused Constants = 0
	//
	// From mesh.options
	// note: this payload length is ONLY the bytes that are sent inside of the radiohead packet
	// Data.payload max_size:240
	Constants_DATA_PAYLOAD_LEN Constants = 240
)

// Enum value maps for Constants.
var (
	Constants_name = map[int32]string{
		0:   "Unused",
		240: "DATA_PAYLOAD_LEN",
	}
	Constants_value = map[string]int32{
		"Unused":           0,
		"DATA_PAYLOAD_LEN": 240,
	}
)

func (x Constants) Enum() *Constants {
	p := new(Constants)
	*p = x
	return p
}

func (x Constants) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Constants) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[1].Descriptor()
}

func (Constants) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[1]
}

func (x Constants) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Constants.Descriptor instead.
func (Constants) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{1}
}

//
// The frequency/regulatory region the user has selected.
//
// Note: In 1.0 builds (which must still be supported by the android app for a
// long time) this field will be unpopulated.
//
// If firmware is ever upgraded from an old 1.0ish build, the old
// MyNodeInfo.region string will be used to set UserPreferences.region and the
// old value will be no longer set.
type RegionCode int32

const (
	RegionCode_Unset RegionCode = 0
	RegionCode_US    RegionCode = 1
	RegionCode_EU433 RegionCode = 2
	RegionCode_EU865 RegionCode = 3
	RegionCode_CN    RegionCode = 4
	RegionCode_JP    RegionCode = 5
	RegionCode_ANZ   RegionCode = 6
	RegionCode_KR    RegionCode = 7
	RegionCode_TW    RegionCode = 8
)

// Enum value maps for RegionCode.
var (
	RegionCode_name = map[int32]string{
		0: "Unset",
		1: "US",
		2: "EU433",
		3: "EU865",
		4: "CN",
		5: "JP",
		6: "ANZ",
		7: "KR",
		8: "TW",
	}
	RegionCode_value = map[string]int32{
		"Unset": 0,
		"US":    1,
		"EU433": 2,
		"EU865": 3,
		"CN":    4,
		"JP":    5,
		"ANZ":   6,
		"KR":    7,
		"TW":    8,
	}
)

func (x RegionCode) Enum() *RegionCode {
	p := new(RegionCode)
	*p = x
	return p
}

func (x RegionCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RegionCode) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[2].Descriptor()
}

func (RegionCode) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[2]
}

func (x RegionCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RegionCode.Descriptor instead.
func (RegionCode) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{2}
}

//
// Sets the charge control current of devices with a battery charger that can be
// configured. This is passed into the axp power management chip like on the tbeam.
type ChargeCurrent int32

const (
	ChargeCurrent_MAUnset ChargeCurrent = 0
	ChargeCurrent_MA100   ChargeCurrent = 1
	ChargeCurrent_MA190   ChargeCurrent = 2
	ChargeCurrent_MA280   ChargeCurrent = 3
	ChargeCurrent_MA360   ChargeCurrent = 4
	ChargeCurrent_MA450   ChargeCurrent = 5
	ChargeCurrent_MA550   ChargeCurrent = 6
	ChargeCurrent_MA630   ChargeCurrent = 7
	ChargeCurrent_MA700   ChargeCurrent = 8
	ChargeCurrent_MA780   ChargeCurrent = 9
	ChargeCurrent_MA880   ChargeCurrent = 10
	ChargeCurrent_MA960   ChargeCurrent = 11
	ChargeCurrent_MA1000  ChargeCurrent = 12
	ChargeCurrent_MA1080  ChargeCurrent = 13
	ChargeCurrent_MA1160  ChargeCurrent = 14
	ChargeCurrent_MA1240  ChargeCurrent = 15
	ChargeCurrent_MA1320  ChargeCurrent = 16
)

// Enum value maps for ChargeCurrent.
var (
	ChargeCurrent_name = map[int32]string{
		0:  "MAUnset",
		1:  "MA100",
		2:  "MA190",
		3:  "MA280",
		4:  "MA360",
		5:  "MA450",
		6:  "MA550",
		7:  "MA630",
		8:  "MA700",
		9:  "MA780",
		10: "MA880",
		11: "MA960",
		12: "MA1000",
		13: "MA1080",
		14: "MA1160",
		15: "MA1240",
		16: "MA1320",
	}
	ChargeCurrent_value = map[string]int32{
		"MAUnset": 0,
		"MA100":   1,
		"MA190":   2,
		"MA280":   3,
		"MA360":   4,
		"MA450":   5,
		"MA550":   6,
		"MA630":   7,
		"MA700":   8,
		"MA780":   9,
		"MA880":   10,
		"MA960":   11,
		"MA1000":  12,
		"MA1080":  13,
		"MA1160":  14,
		"MA1240":  15,
		"MA1320":  16,
	}
)

func (x ChargeCurrent) Enum() *ChargeCurrent {
	p := new(ChargeCurrent)
	*p = x
	return p
}

func (x ChargeCurrent) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChargeCurrent) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[3].Descriptor()
}

func (ChargeCurrent) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[3]
}

func (x ChargeCurrent) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChargeCurrent.Descriptor instead.
func (ChargeCurrent) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{3}
}

//
// How the GPS hardware in this unit is operated.
// Note: This is independent of how our location is shared with other devices.  For that see LocationSharing
type GpsOperation int32

const (
	//
	// This is treated as GpsOpMobile - it is the default setting
	GpsOperation_GpsOpUnset GpsOperation = 0
	//
	// Note: This mode was removed, because it is identical go GpsOpMobile with a gps_update_rate of once per day
	//
	// This node is mostly stationary, we should try to get location only once per day,
	// Once we have that position we should turn the GPS to sleep mode
	// This is the recommended configuration for stationary 'router' nodes
	GpsOperation_GpsOpStationary GpsOperation = 1
	//
	// This node is mobile and we should get GPS position at a rate governed by gps_update_rate
	GpsOperation_GpsOpMobile GpsOperation = 2
	//
	// We should only use the GPS to get time (no location data should be acquired/stored)
	// Once we have the time we treat gps_update_interval as MAXINT (i.e. sleep forever)
	GpsOperation_GpsOpTimeOnly GpsOperation = 3
	//
	// GPS is always turned off - this mode is not recommended - use GpsOpTimeOnly instead
	GpsOperation_GpsOpDisabled GpsOperation = 4
)

// Enum value maps for GpsOperation.
var (
	GpsOperation_name = map[int32]string{
		0: "GpsOpUnset",
		1: "GpsOpStationary",
		2: "GpsOpMobile",
		3: "GpsOpTimeOnly",
		4: "GpsOpDisabled",
	}
	GpsOperation_value = map[string]int32{
		"GpsOpUnset":      0,
		"GpsOpStationary": 1,
		"GpsOpMobile":     2,
		"GpsOpTimeOnly":   3,
		"GpsOpDisabled":   4,
	}
)

func (x GpsOperation) Enum() *GpsOperation {
	p := new(GpsOperation)
	*p = x
	return p
}

func (x GpsOperation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GpsOperation) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[4].Descriptor()
}

func (GpsOperation) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[4]
}

func (x GpsOperation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GpsOperation.Descriptor instead.
func (GpsOperation) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{4}
}

//
// How our location is shared with other nodes (or the local phone)
type LocationSharing int32

const (
	//
	// This is the default and treated as LocEnabled)
	LocationSharing_LocUnset LocationSharing = 0
	//
	// We are sharing our location
	LocationSharing_LocEnabled LocationSharing = 1
	//
	// We are not sharing our location (if the unit has a GPS it will default to only get time - i.e. GpsOpTimeOnly)
	LocationSharing_LocDisabled LocationSharing = 2
)

// Enum value maps for LocationSharing.
var (
	LocationSharing_name = map[int32]string{
		0: "LocUnset",
		1: "LocEnabled",
		2: "LocDisabled",
	}
	LocationSharing_value = map[string]int32{
		"LocUnset":    0,
		"LocEnabled":  1,
		"LocDisabled": 2,
	}
)

func (x LocationSharing) Enum() *LocationSharing {
	p := new(LocationSharing)
	*p = x
	return p
}

func (x LocationSharing) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LocationSharing) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[5].Descriptor()
}

func (LocationSharing) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[5]
}

func (x LocationSharing) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LocationSharing.Descriptor instead.
func (LocationSharing) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{5}
}

//* Error codes for critical errors
//
// The device might report these fault codes on the screen.
// If you encounter a fault code, please post on the meshtastic.discourse.group
// and we'll try to help.
type CriticalErrorCode int32

const (
	CriticalErrorCode_None CriticalErrorCode = 0
	//
	// A software bug was detected while trying to send lora
	CriticalErrorCode_TxWatchdog CriticalErrorCode = 1
	//
	// A software bug was detected on entry to sleep
	CriticalErrorCode_SleepEnterWait CriticalErrorCode = 2
	//
	// No Lora radio hardware could be found
	CriticalErrorCode_NoRadio CriticalErrorCode = 3
	//
	// Not normally used
	CriticalErrorCode_Unspecified CriticalErrorCode = 4
	//
	// We failed while configuring a UBlox GPS
	CriticalErrorCode_UBloxInitFailed CriticalErrorCode = 5
	//
	// This board was expected to have a power management chip and it is missing or broken
	CriticalErrorCode_NoAXP192 CriticalErrorCode = 6
	//
	// The channel tried to set a radio setting which is not supported by this chipset,
	// radio comms settings are now undefined.
	CriticalErrorCode_InvalidRadioSetting CriticalErrorCode = 7
	//
	// Radio transmit hardware failure. We sent data to the radio chip, but it didn't
	// reply with an interrupt.
	CriticalErrorCode_TransmitFailed CriticalErrorCode = 8
)

// Enum value maps for CriticalErrorCode.
var (
	CriticalErrorCode_name = map[int32]string{
		0: "None",
		1: "TxWatchdog",
		2: "SleepEnterWait",
		3: "NoRadio",
		4: "Unspecified",
		5: "UBloxInitFailed",
		6: "NoAXP192",
		7: "InvalidRadioSetting",
		8: "TransmitFailed",
	}
	CriticalErrorCode_value = map[string]int32{
		"None":                0,
		"TxWatchdog":          1,
		"SleepEnterWait":      2,
		"NoRadio":             3,
		"Unspecified":         4,
		"UBloxInitFailed":     5,
		"NoAXP192":            6,
		"InvalidRadioSetting": 7,
		"TransmitFailed":      8,
	}
)

func (x CriticalErrorCode) Enum() *CriticalErrorCode {
	p := new(CriticalErrorCode)
	*p = x
	return p
}

func (x CriticalErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CriticalErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[6].Descriptor()
}

func (CriticalErrorCode) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[6]
}

func (x CriticalErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CriticalErrorCode.Descriptor instead.
func (CriticalErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{6}
}

// The priority of this message for sending.  Higher priorities are sent first
//(when managing the transmit queue).
//This field is never sent over the air, it is only used internally inside of a local device node.
//API clients (either on the local node or connected directly to the node)
//can set this parameter if necessary.
//
//(values must be <= 127 to keep protobuf field to one byte in size.
//
//Detailed background on this field:
//
//I noticed a funny side effect of lora being so slow: Usually when making
//a protocol there isn’t much need to use message priority to change the order
//of transmission (because interfaces are fairly fast).
//But for lora where packets can take a few seconds each, it is very important
//to make sure that critical packets are sent ASAP.
//In the case of meshtastic that means we want to send protocol acks as soon as possible
//(to prevent unneeded retransmissions), we want routing messages to be sent next,
//then messages marked as reliable and finally ‘background’ packets like periodic position updates.
//
//So I bit the bullet and implemented a new (internal - not sent over the air)
//field in MeshPacket called ‘priority’.
//And the transmission queue in the router object is now a priority queue.
type MeshPacket_Priority int32

const (
	// Treated as Priority.DEFAULT
	MeshPacket_UNSET MeshPacket_Priority = 0
	MeshPacket_MIN   MeshPacket_Priority = 1
	// Background position updates are sent with very low priority -
	// if the link is super congested they might not go out at all
	MeshPacket_BACKGROUND MeshPacket_Priority = 10
	// This priority is used for most messages that don't have a priority set
	MeshPacket_DEFAULT MeshPacket_Priority = 64
	// If priority is unset but the message is marked as want_ack,
	// assume it is important and use a slightly higher priority
	MeshPacket_RELIABLE MeshPacket_Priority = 70
	// Ack/naks are sent with very high priority to ensure that retransmission
	// stops as soon as possible
	MeshPacket_ACK MeshPacket_Priority = 120
	MeshPacket_MAX MeshPacket_Priority = 127
)

// Enum value maps for MeshPacket_Priority.
var (
	MeshPacket_Priority_name = map[int32]string{
		0:   "UNSET",
		1:   "MIN",
		10:  "BACKGROUND",
		64:  "DEFAULT",
		70:  "RELIABLE",
		120: "ACK",
		127: "MAX",
	}
	MeshPacket_Priority_value = map[string]int32{
		"UNSET":      0,
		"MIN":        1,
		"BACKGROUND": 10,
		"DEFAULT":    64,
		"RELIABLE":   70,
		"ACK":        120,
		"MAX":        127,
	}
)

func (x MeshPacket_Priority) Enum() *MeshPacket_Priority {
	p := new(MeshPacket_Priority)
	*p = x
	return p
}

func (x MeshPacket_Priority) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MeshPacket_Priority) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[7].Descriptor()
}

func (MeshPacket_Priority) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[7]
}

func (x MeshPacket_Priority) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MeshPacket_Priority.Descriptor instead.
func (MeshPacket_Priority) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{5, 0}
}

//
// Standard predefined channel settings
// Note: these mappings must match ModemConfigChoice in the device code.
type ChannelSettings_ModemConfig int32

const (
	//
	// < Bw = 125 kHz, Cr = 4/5, Sf(7) = 128chips/symbol, CRC
	// < on. Default medium range (5.469 kbps)
	ChannelSettings_Bw125Cr45Sf128 ChannelSettings_ModemConfig = 0
	//
	// < Bw = 500 kHz, Cr = 4/5, Sf(7) = 128chips/symbol, CRC
	// < on. Fast+short range (21.875 kbps)
	ChannelSettings_Bw500Cr45Sf128 ChannelSettings_ModemConfig = 1
	//
	// < Bw = 31.25 kHz, Cr = 4/8, Sf(9) = 512chips/symbol,
	// < CRC on. Slow+long range (275 bps)
	ChannelSettings_Bw31_25Cr48Sf512 ChannelSettings_ModemConfig = 2
	//
	// < Bw = 125 kHz, Cr = 4/8, Sf(12) = 4096chips/symbol, CRC
	// < on. Slow+long range (183 bps)
	ChannelSettings_Bw125Cr48Sf4096 ChannelSettings_ModemConfig = 3
)

// Enum value maps for ChannelSettings_ModemConfig.
var (
	ChannelSettings_ModemConfig_name = map[int32]string{
		0: "Bw125Cr45Sf128",
		1: "Bw500Cr45Sf128",
		2: "Bw31_25Cr48Sf512",
		3: "Bw125Cr48Sf4096",
	}
	ChannelSettings_ModemConfig_value = map[string]int32{
		"Bw125Cr45Sf128":   0,
		"Bw500Cr45Sf128":   1,
		"Bw31_25Cr48Sf512": 2,
		"Bw125Cr48Sf4096":  3,
	}
)

func (x ChannelSettings_ModemConfig) Enum() *ChannelSettings_ModemConfig {
	p := new(ChannelSettings_ModemConfig)
	*p = x
	return p
}

func (x ChannelSettings_ModemConfig) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChannelSettings_ModemConfig) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[8].Descriptor()
}

func (ChannelSettings_ModemConfig) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[8]
}

func (x ChannelSettings_ModemConfig) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChannelSettings_ModemConfig.Descriptor instead.
func (ChannelSettings_ModemConfig) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{6, 0}
}

//
// Log levels, chosen to match python logging conventions.
type LogRecord_Level int32

const (
	LogRecord_UNSET    LogRecord_Level = 0
	LogRecord_CRITICAL LogRecord_Level = 50
	LogRecord_ERROR    LogRecord_Level = 40
	LogRecord_WARNING  LogRecord_Level = 30
	LogRecord_INFO     LogRecord_Level = 20
	LogRecord_DEBUG    LogRecord_Level = 10
	LogRecord_TRACE    LogRecord_Level = 5
)

// Enum value maps for LogRecord_Level.
var (
	LogRecord_Level_name = map[int32]string{
		0:  "UNSET",
		50: "CRITICAL",
		40: "ERROR",
		30: "WARNING",
		20: "INFO",
		10: "DEBUG",
		5:  "TRACE",
	}
	LogRecord_Level_value = map[string]int32{
		"UNSET":    0,
		"CRITICAL": 50,
		"ERROR":    40,
		"WARNING":  30,
		"INFO":     20,
		"DEBUG":    10,
		"TRACE":    5,
	}
)

func (x LogRecord_Level) Enum() *LogRecord_Level {
	p := new(LogRecord_Level)
	*p = x
	return p
}

func (x LogRecord_Level) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogRecord_Level) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[9].Descriptor()
}

func (LogRecord_Level) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[9]
}

func (x LogRecord_Level) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogRecord_Level.Descriptor instead.
func (LogRecord_Level) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{10, 0}
}

//
// a gps position
type Position struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// The new preferred location encoding, divide by 1e-7 to get degrees
	// in floating point
	LatitudeI  int32 `protobuf:"zigzag32,7,opt,name=latitude_i,json=latitudeI,proto3" json:"latitude_i,omitempty"`
	LongitudeI int32 `protobuf:"zigzag32,8,opt,name=longitude_i,json=longitudeI,proto3" json:"longitude_i,omitempty"`
	//
	// In meters above MSL
	Altitude int32 `protobuf:"varint,3,opt,name=altitude,proto3" json:"altitude,omitempty"`
	//
	// 1-100 (0 means not provided)
	BatteryLevel int32 `protobuf:"varint,4,opt,name=battery_level,json=batteryLevel,proto3" json:"battery_level,omitempty"`
	//
	// This is usually not sent over the mesh (to save space), but it is sent
	// from the phone so that the local device can set its RTC If it is sent over
	// the mesh (because there are devices on the mesh without GPS), it will only
	// be sent by devices which has a hardware GPS clock.
	// seconds since 1970
	Time uint32 `protobuf:"fixed32,9,opt,name=time,proto3" json:"time,omitempty"`
}

func (x *Position) Reset() {
	*x = Position{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Position) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Position) ProtoMessage() {}

func (x *Position) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Position.ProtoReflect.Descriptor instead.
func (*Position) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{0}
}

func (x *Position) GetLatitudeI() int32 {
	if x != nil {
		return x.LatitudeI
	}
	return 0
}

func (x *Position) GetLongitudeI() int32 {
	if x != nil {
		return x.LongitudeI
	}
	return 0
}

func (x *Position) GetAltitude() int32 {
	if x != nil {
		return x.Altitude
	}
	return 0
}

func (x *Position) GetBatteryLevel() int32 {
	if x != nil {
		return x.BatteryLevel
	}
	return 0
}

func (x *Position) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

//
// a data message to forward to an external app (or possibly also be consumed
// internally in the case of CLEAR_TEXT and CLEAR_READACK)
type Data struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// Formerly named typ and of type Type
	Portnum PortNum `protobuf:"varint,1,opt,name=portnum,proto3,enum=PortNum" json:"portnum,omitempty"`
	//
	// Required
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (x *Data) Reset() {
	*x = Data{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Data) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data) ProtoMessage() {}

func (x *Data) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{1}
}

func (x *Data) GetPortnum() PortNum {
	if x != nil {
		return x.Portnum
	}
	return PortNum_UNKNOWN_APP
}

func (x *Data) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

//
// Broadcast when a newly powered mesh node wants to find a node num it can use
// Sent from the phone over bluetooth to set the user id for the owner of this node.
// Also sent from nodes to each other when a new node signs on (so all clients can have this info)
//
// The algorithm is as follows:
// when a node starts up, it broadcasts their user and the normal flow is for all
// other nodes to reply with their User as well (so the new node can build its nodedb)
// If a node ever receives a User (not just the first broadcast) message where
// the sender node number equals our node number, that indicates a collision has
// occurred and the following steps should happen:
//
// If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
// new User who just tried to sign in: it gets to keep its nodenum.  We send a
// broadcast message of OUR User (we use a broadcast so that the other node can
// receive our message, considering we have the same id - it also serves to let
// observers correct their nodedb) - this case is rare so it should be okay.
//
// If any node receives a User where the macaddr is GTE than their local macaddr,
// they have been vetoed and should pick a new random nodenum (filtering against
// whatever it knows about the nodedb) and rebroadcast their User.
//
// A few nodenums are reserved and will never be requested:
// 0xff - broadcast
// 0 through 3 - for future use
type User struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// A globally unique ID string for this user.  In the case of
	// Signal that would mean +16504442323, for the default macaddr
	// derived id it would be !<8 hexidecimal bytes>
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	//
	// A full name for this user, i.e. "Kevin Hester"
	LongName string `protobuf:"bytes,2,opt,name=long_name,json=longName,proto3" json:"long_name,omitempty"`
	//
	// A VERY short name, ideally two characters.  Suitable for a tiny OLED screen
	ShortName string `protobuf:"bytes,3,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	//
	// This is the addr of the radio.  Not populated by the phone,
	// but added by the esp32 when broadcasting
	Macaddr []byte `protobuf:"bytes,4,opt,name=macaddr,proto3" json:"macaddr,omitempty"`
}

func (x *User) Reset() {
	*x = User{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*User) ProtoMessage() {}

func (x *User) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{2}
}

func (x *User) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *User) GetLongName() string {
	if x != nil {
		return x.LongName
	}
	return ""
}

func (x *User) GetShortName() string {
	if x != nil {
		return x.ShortName
	}
	return ""
}

func (x *User) GetMacaddr() []byte {
	if x != nil {
		return x.Macaddr
	}
	return nil
}

//
// A message used in our Dynamic Source Routing protocol (RFC 4728 based)
type RouteDiscovery struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// The list of nodes this packet has visited so far
	Route []int32 `protobuf:"varint,2,rep,packed,name=route,proto3" json:"route,omitempty"`
}

func (x *RouteDiscovery) Reset() {
	*x = RouteDiscovery{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteDiscovery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteDiscovery) ProtoMessage() {}

func (x *RouteDiscovery) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteDiscovery.ProtoReflect.Descriptor instead.
func (*RouteDiscovery) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{3}
}

func (x *RouteDiscovery) GetRoute() []int32 {
	if x != nil {
		return x.Route
	}
	return nil
}

//
// The payload portion fo a packet, this is the actual bytes that are sent
// inside a radio packet (because from/to are broken out by the comms library)
type SubPacket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// Only one of the following fields can be populated at a time
	//
	// Types that are assignable to PayloadVariant:
	//	*SubPacket_Data
	//	*SubPacket_RouteRequest
	//	*SubPacket_RouteReply
	//	*SubPacket_ErrorReason
	//	*SubPacket_Position
	//	*SubPacket_User
	PayloadVariant isSubPacket_PayloadVariant `protobuf_oneof:"payloadVariant"`
	//
	// Not normally used, but for testing a sender can request that recipient
	// responds in kind (i.e. if it received a position, it should unicast back it's position).
	// Note: that if you set this on a broadcast you will receive many replies.
	WantResponse bool `protobuf:"varint,5,opt,name=want_response,json=wantResponse,proto3" json:"want_response,omitempty"`
	// Types that are assignable to AckVariant:
	//	*SubPacket_SuccessId
	//	*SubPacket_FailId
	AckVariant isSubPacket_AckVariant `protobuf_oneof:"ackVariant"`
	//
	// The address of the destination node.
	// This field is is filled in by the mesh radio device software, application
	// layer software should never need it.
	// RouteDiscovery messages _must_ populate this.  Other message types might need
	// to if they are doing multihop routing.
	Dest uint32 `protobuf:"varint,9,opt,name=dest,proto3" json:"dest,omitempty"`
	//
	// The address of the original sender for this message.
	// This field should _only_ be populated for reliable multihop packets (to keep
	// packets small).
	Source uint32 `protobuf:"varint,12,opt,name=source,proto3" json:"source,omitempty"`
	//
	// Only used in route_error messages.  Indicates the original message ID that
	// this message is reporting failure on.
	OriginalId uint32 `protobuf:"varint,2,opt,name=original_id,json=originalId,proto3" json:"original_id,omitempty"`
}

func (x *SubPacket) Reset() {
	*x = SubPacket{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SubPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubPacket) ProtoMessage() {}

func (x *SubPacket) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubPacket.ProtoReflect.Descriptor instead.
func (*SubPacket) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{4}
}

func (m *SubPacket) GetPayloadVariant() isSubPacket_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *SubPacket) GetData() *Data {
	if x, ok := x.GetPayloadVariant().(*SubPacket_Data); ok {
		return x.Data
	}
	return nil
}

func (x *SubPacket) GetRouteRequest() *RouteDiscovery {
	if x, ok := x.GetPayloadVariant().(*SubPacket_RouteRequest); ok {
		return x.RouteRequest
	}
	return nil
}

func (x *SubPacket) GetRouteReply() *RouteDiscovery {
	if x, ok := x.GetPayloadVariant().(*SubPacket_RouteReply); ok {
		return x.RouteReply
	}
	return nil
}

func (x *SubPacket) GetErrorReason() ErrorReason {
	if x, ok := x.GetPayloadVariant().(*SubPacket_ErrorReason); ok {
		return x.ErrorReason
	}
	return ErrorReason_NONE
}

// Deprecated: Do not use.
func (x *SubPacket) GetPosition() *Position {
	if x, ok := x.GetPayloadVariant().(*SubPacket_Position); ok {
		return x.Position
	}
	return nil
}

// Deprecated: Do not use.
func (x *SubPacket) GetUser() *User {
	if x, ok := x.GetPayloadVariant().(*SubPacket_User); ok {
		return x.User
	}
	return nil
}

func (x *SubPacket) GetWantResponse() bool {
	if x != nil {
		return x.WantResponse
	}
	return false
}

func (m *SubPacket) GetAckVariant() isSubPacket_AckVariant {
	if m != nil {
		return m.AckVariant
	}
	return nil
}

func (x *SubPacket) GetSuccessId() uint32 {
	if x, ok := x.GetAckVariant().(*SubPacket_SuccessId); ok {
		return x.SuccessId
	}
	return 0
}

func (x *SubPacket) GetFailId() uint32 {
	if x, ok := x.GetAckVariant().(*SubPacket_FailId); ok {
		return x.FailId
	}
	return 0
}

func (x *SubPacket) GetDest() uint32 {
	if x != nil {
		return x.Dest
	}
	return 0
}

func (x *SubPacket) GetSource() uint32 {
	if x != nil {
		return x.Source
	}
	return 0
}

func (x *SubPacket) GetOriginalId() uint32 {
	if x != nil {
		return x.OriginalId
	}
	return 0
}

type isSubPacket_PayloadVariant interface {
	isSubPacket_PayloadVariant()
}

type SubPacket_Data struct {
	Data *Data `protobuf:"bytes,3,opt,name=data,proto3,oneof"`
}

type SubPacket_RouteRequest struct {
	//
	// A route request going from the requester
	// FIXME - these route messages should be moved into regular data packets and
	// use the regular on device plugin mechanism.
	RouteRequest *RouteDiscovery `protobuf:"bytes,6,opt,name=route_request,json=routeRequest,proto3,oneof"`
}

type SubPacket_RouteReply struct {
	//
	// A route reply
	RouteReply *RouteDiscovery `protobuf:"bytes,7,opt,name=route_reply,json=routeReply,proto3,oneof"`
}

type SubPacket_ErrorReason struct {
	//
	// A failure in delivering a message (usually used for routing control messages,
	// but might be provided in addition to ack.fail_id to provide
	// details on the type of failure).
	ErrorReason ErrorReason `protobuf:"varint,13,opt,name=error_reason,json=errorReason,proto3,enum=ErrorReason,oneof"`
}

type SubPacket_Position struct {
	//
	// Prior to 1.20 positions were communicated as a special payload type,
	// now they are GPS_POSITION_APP Data
	//
	// Deprecated: Do not use.
	Position *Position `protobuf:"bytes,1,opt,name=position,proto3,oneof"`
}

type SubPacket_User struct {
	//
	// Prior to 1.20 positions were communicated as a special payload type,
	// now they are MESH_USERINFO_APP
	//
	// Deprecated: Do not use.
	User *User `protobuf:"bytes,4,opt,name=user,proto3,oneof"`
}

func (*SubPacket_Data) isSubPacket_PayloadVariant() {}

func (*SubPacket_RouteRequest) isSubPacket_PayloadVariant() {}

func (*SubPacket_RouteReply) isSubPacket_PayloadVariant() {}

func (*SubPacket_ErrorReason) isSubPacket_PayloadVariant() {}

func (*SubPacket_Position) isSubPacket_PayloadVariant() {}

func (*SubPacket_User) isSubPacket_PayloadVariant() {}

type isSubPacket_AckVariant interface {
	isSubPacket_AckVariant()
}

type SubPacket_SuccessId struct {
	//
	// This packet is a requested acknowledgment indicating that we have received
	// the specified message ID.  This packet type can be used both for immediate
	// (0 hops) messages or can be routed through multiple hops if dest is set.
	// Note: As an optimization, recipients can _also_ populate a field in payload
	// if they think the recipient would appreciate that extra state.
	SuccessId uint32 `protobuf:"varint,10,opt,name=success_id,json=successId,proto3,oneof"`
}

type SubPacket_FailId struct {
	//
	// This is a nak, we failed to deliver this message.
	FailId uint32 `protobuf:"varint,11,opt,name=fail_id,json=failId,proto3,oneof"`
}

func (*SubPacket_SuccessId) isSubPacket_AckVariant() {}

func (*SubPacket_FailId) isSubPacket_AckVariant() {}

//
// A full packet sent/received over the mesh
// Note: For simplicity reasons (and that we want to keep over the radio packets
// very small, we now assume that there is only _one_ SubPacket in each MeshPacket).
type MeshPacket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// The sending node number.
	// Note: Our crypto implementation uses this field as well.  See
	// docs/software/crypto.md for details.
	// FIXME - really should be fixed32 instead, this encoding only hurts the ble link though.
	From uint32 `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
	//
	// The (immediatSee Priority description for more details.y should be fixed32 instead, this encoding only
	// hurts the ble link though.
	To uint32 `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"`
	//
	// If set, this indicates the index in the secondary_channels table that this packet
	// was sent/received on.  If unset, packet was on the primary channel.
	// A particular node might know only a subset of channels in use on the mesh.  Therefore channel_index
	// is inherently a local concept and meaningless to send between nodes.
	ChannelIndex uint32 `protobuf:"varint,4,opt,name=channel_index,json=channelIndex,proto3" json:"channel_index,omitempty"`
	// Types that are assignable to PayloadVariant:
	//	*MeshPacket_Decoded
	//	*MeshPacket_Encrypted
	PayloadVariant isMeshPacket_PayloadVariant `protobuf_oneof:"payloadVariant"`
	//
	// A unique ID for this packet.  Always 0 for no-ack packets or non broadcast
	// packets (and therefore take zero bytes of space).  Otherwise a unique ID for
	// this packet, useful for flooding algorithms.
	// ID only needs to be unique on a _per sender_ basis, and it only
	// needs to be unique for a few minutes (long enough to last for the length of
	// any ACK or the completion of a mesh broadcast flood).
	// Note: Our crypto implementation uses this id as well.  See docs/software/crypto.md for details.
	// FIXME - really should be fixed32 instead, this encoding only
	// hurts the ble link though.
	Id uint32 `protobuf:"varint,6,opt,name=id,proto3" json:"id,omitempty"`
	//
	// The time this message was received by the esp32 (secs since 1970).  Note:
	// this field is _never_ sent on the radio link itself (to save space) Times
	// are typically not sent over the mesh, but they will be added to any Packet
	// (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
	RxTime uint32 `protobuf:"fixed32,9,opt,name=rx_time,json=rxTime,proto3" json:"rx_time,omitempty"`
	//
	// *Never* sent over the radio links.  Set during reception to indicate the SNR
	// of this packet.  Used to collect statistics on current link quality.
	RxSnr float32 `protobuf:"fixed32,7,opt,name=rx_snr,json=rxSnr,proto3" json:"rx_snr,omitempty"`
	//
	// If unset treated as zero (no forwarding, send to adjacent nodes only)
	// if 1, allow hopping through one node, etc...
	// For our usecase real world topologies probably have a max of about 3.
	// This field is normally placed into a few of bits in the header.
	HopLimit uint32 `protobuf:"varint,10,opt,name=hop_limit,json=hopLimit,proto3" json:"hop_limit,omitempty"`
	//
	// This packet is being sent as a reliable message, we would prefer it to arrive
	// at the destination.  We would like to receive a ack packet in response.
	// Broadcasts messages treat this flag specially: Since acks for broadcasts would
	// rapidly flood the channel, the normal ack behavior is suppressed.  Instead,
	// the original sender listens to see if at least one node is rebroadcasting this
	// packet (because naive flooding algorithm).  If it hears that the odds (given
	// typical LoRa topologies) the odds are very high that every node should
	// eventually receive the message.  So FloodingRouter.cpp generates an implicit
	// ack which is delivered to the original sender. If after some time we don't
	// hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
	// Note: This flag is normally sent in a flag bit in the header when sent over the wire
	WantAck bool `protobuf:"varint,11,opt,name=want_ack,json=wantAck,proto3" json:"want_ack,omitempty"`
	// The priority of this message for sending.
	//See MeshPacket.Priority description for more details.
	Priority MeshPacket_Priority `protobuf:"varint,12,opt,name=priority,proto3,enum=MeshPacket_Priority" json:"priority,omitempty"`
}

func (x *MeshPacket) Reset() {
	*x = MeshPacket{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MeshPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MeshPacket) ProtoMessage() {}

func (x *MeshPacket) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MeshPacket.ProtoReflect.Descriptor instead.
func (*MeshPacket) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{5}
}

func (x *MeshPacket) GetFrom() uint32 {
	if x != nil {
		return x.From
	}
	return 0
}

func (x *MeshPacket) GetTo() uint32 {
	if x != nil {
		return x.To
	}
	return 0
}

func (x *MeshPacket) GetChannelIndex() uint32 {
	if x != nil {
		return x.ChannelIndex
	}
	return 0
}

func (m *MeshPacket) GetPayloadVariant() isMeshPacket_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *MeshPacket) GetDecoded() *SubPacket {
	if x, ok := x.GetPayloadVariant().(*MeshPacket_Decoded); ok {
		return x.Decoded
	}
	return nil
}

func (x *MeshPacket) GetEncrypted() []byte {
	if x, ok := x.GetPayloadVariant().(*MeshPacket_Encrypted); ok {
		return x.Encrypted
	}
	return nil
}

func (x *MeshPacket) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *MeshPacket) GetRxTime() uint32 {
	if x != nil {
		return x.RxTime
	}
	return 0
}

func (x *MeshPacket) GetRxSnr() float32 {
	if x != nil {
		return x.RxSnr
	}
	return 0
}

func (x *MeshPacket) GetHopLimit() uint32 {
	if x != nil {
		return x.HopLimit
	}
	return 0
}

func (x *MeshPacket) GetWantAck() bool {
	if x != nil {
		return x.WantAck
	}
	return false
}

func (x *MeshPacket) GetPriority() MeshPacket_Priority {
	if x != nil {
		return x.Priority
	}
	return MeshPacket_UNSET
}

type isMeshPacket_PayloadVariant interface {
	isMeshPacket_PayloadVariant()
}

type MeshPacket_Decoded struct {
	Decoded *SubPacket `protobuf:"bytes,3,opt,name=decoded,proto3,oneof"`
}

type MeshPacket_Encrypted struct {
	Encrypted []byte `protobuf:"bytes,8,opt,name=encrypted,proto3,oneof"`
}

func (*MeshPacket_Decoded) isMeshPacket_PayloadVariant() {}

func (*MeshPacket_Encrypted) isMeshPacket_PayloadVariant() {}

//
// Full settings (center freq, spread factor, pre-shared secret key etc...)
// needed to configure a radio for speaking on a particular channel This
// information can be encoded as a QRcode/url so that other users can configure
// their radio to join the same channel.
// A note about how channel names are shown to users: channelname-Xy
// poundsymbol is a prefix used to indicate this is a channel name (idea from @professr).
// Where X is a letter from A-Z (base 26) representing a hash of the PSK for this
// channel - so that if the user changes anything about the channel (which does
// force a new PSK) this letter will also change. Thus preventing user confusion if
// two friends try to type in a channel name of "BobsChan" and then can't talk
// because their PSKs will be different.  The PSK is hashed into this letter by
// "0x41 + [xor all bytes of the psk ] modulo 26"
// This also allows the option of someday if people have the PSK off (zero), the
// users COULD type in a channel name and be able to talk.
// Y is a lower case letter from a-z that represents the channel 'speed' settings
// (for some future definition of speed)
//
// FIXME: Add description of multi-channel support and how primary vs secondary channels are used.
// FIXME: explain how apps use channels for security.  explain how remote settings and
// remote gpio are managed as an example
type ChannelSettings struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// If zero then, use default max legal continuous power (ie. something that won't
	// burn out the radio hardware)
	// In most cases you should use zero here.
	TxPower int32 `protobuf:"varint,1,opt,name=tx_power,json=txPower,proto3" json:"tx_power,omitempty"`
	//
	// Note: This is the 'old' mechanism for specifying channel parameters.
	// Either modem_config or bandwidth/spreading/coding will be specified - NOT
	// BOTH. As a heuristic: If bandwidth is specified, do not use modem_config.
	// Because protobufs take ZERO space when the value is zero this works out
	// nicely.
	// This value is replaced by bandwidth/spread_factor/coding_rate.  If you'd
	// like to experiment with other options add them to MeshRadio.cpp in the
	// device code.
	ModemConfig ChannelSettings_ModemConfig `protobuf:"varint,3,opt,name=modem_config,json=modemConfig,proto3,enum=ChannelSettings_ModemConfig" json:"modem_config,omitempty"`
	//
	// Bandwidth in MHz
	// Certain bandwidth numbers are 'special' and will be converted to the
	// appropriate floating point value: 31 -> 31.25MHz
	Bandwidth uint32 `protobuf:"varint,6,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	//
	// A number from 7 to 12.  Indicates number of chirps per symbol as
	// 1<<spread_factor.
	SpreadFactor uint32 `protobuf:"varint,7,opt,name=spread_factor,json=spreadFactor,proto3" json:"spread_factor,omitempty"`
	//
	// The denominator of the coding rate.  ie for 4/8, the value is 8. 5/8 the value is 5.
	CodingRate uint32 `protobuf:"varint,8,opt,name=coding_rate,json=codingRate,proto3" json:"coding_rate,omitempty"`
	//
	// A channel number between 1 and 13 (or whatever the max is in the current
	// region). If ZERO then the rule is "use the old channel name hash based
	// algorithm to derive the channel number")
	// If using the hash algorithm the channel number will be: hash(channel_name) %
	// NUM_CHANNELS (Where num channels depends on the regulatory region).
	// NUM_CHANNELS_US is 13, for other values see MeshRadio.h in the device code.
	// hash a string into an integer - djb2 by Dan Bernstein. -
	// http://www.cse.yorku.ca/~oz/hash.html
	// unsigned long hash(char *str) {
	//   unsigned long hash = 5381; int c;
	//   while ((c = *str++) != 0)
	//     hash = ((hash << 5) + hash) + (unsigned char) c;
	//   return hash;
	// }
	ChannelNum uint32 `protobuf:"varint,9,opt,name=channel_num,json=channelNum,proto3" json:"channel_num,omitempty"`
	//
	// A simple pre-shared key for now for crypto.  Must be either 0 bytes (no
	// crypto), 16 bytes (AES128), or 32 bytes (AES256)
	// A special shorthand is used for 1 byte long psks.
	// These psks should be treated as only minimally secure,
	// because they are listed in this source code.  Those bytes are mapped using the following scheme:
	// 0 = No crypto
	// 1 = The special default channel key: {0xd4, 0xf1, 0xbb, 0x3a, 0x20, 0x29, 0x07, 0x59, 0xf0, 0xbc, 0xff, 0xab, 0xcf, 0x4e, 0x69, 0xbf}
	// 2 through 10 = The default channel key, except with 1 through 9 added to the last byte
	Psk []byte `protobuf:"bytes,4,opt,name=psk,proto3" json:"psk,omitempty"`
	//
	// A SHORT name that will be packed into the URL.  Less than 12 bytes.
	// Something for end users to call the channel
	// If this is the empty string it is assumed that this channel
	// is the special (minimally secure) "Default"channel.
	// In user interfaces it should be rendered as a local language translation of "X".  For channel_num
	// hashing empty string will be treated as "X".
	// Where "X" is selected based on the English words listed above for ModemConfig
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	//
	// Used to construct a globally unique channel ID.  The full globally unique ID will be: "name.id"
	// where ID is shown as base36.  Assuming that the number of meshtastic users is below 20K (true for a long time)
	// the chance of this 64 bit random number colliding with anyone else is super low.  And the penalty for
	// collision is low as well, it just means that anyone trying to decrypt channel messages might need to
	// try multiple candidate channels.
	// Any time a non wire compatible change is made to a channel, this field should be regenerated.
	// There are a small number of 'special' globally known (and fairly) insecure standard channels.
	// Those channels do not have a numeric id included in the settings, but instead it is pulled from
	// a table of well known IDs.  (see Well Known Channels FIXME)
	Id uint32 `protobuf:"fixed32,10,opt,name=id,proto3" json:"id,omitempty"`
	//
	// If true, messages on the mesh will be sent to the *public* internet by any gateway ndoe
	UplinkEnabled bool `protobuf:"varint,16,opt,name=uplink_enabled,json=uplinkEnabled,proto3" json:"uplink_enabled,omitempty"`
	//
	// If true, messages seen on the internet will be forwarded to the local mesh.
	DownlinkEnabled bool `protobuf:"varint,17,opt,name=downlink_enabled,json=downlinkEnabled,proto3" json:"downlink_enabled,omitempty"`
}

func (x *ChannelSettings) Reset() {
	*x = ChannelSettings{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ChannelSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelSettings) ProtoMessage() {}

func (x *ChannelSettings) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelSettings.ProtoReflect.Descriptor instead.
func (*ChannelSettings) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{6}
}

func (x *ChannelSettings) GetTxPower() int32 {
	if x != nil {
		return x.TxPower
	}
	return 0
}

func (x *ChannelSettings) GetModemConfig() ChannelSettings_ModemConfig {
	if x != nil {
		return x.ModemConfig
	}
	return ChannelSettings_Bw125Cr45Sf128
}

func (x *ChannelSettings) GetBandwidth() uint32 {
	if x != nil {
		return x.Bandwidth
	}
	return 0
}

func (x *ChannelSettings) GetSpreadFactor() uint32 {
	if x != nil {
		return x.SpreadFactor
	}
	return 0
}

func (x *ChannelSettings) GetCodingRate() uint32 {
	if x != nil {
		return x.CodingRate
	}
	return 0
}

func (x *ChannelSettings) GetChannelNum() uint32 {
	if x != nil {
		return x.ChannelNum
	}
	return 0
}

func (x *ChannelSettings) GetPsk() []byte {
	if x != nil {
		return x.Psk
	}
	return nil
}

func (x *ChannelSettings) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ChannelSettings) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *ChannelSettings) GetUplinkEnabled() bool {
	if x != nil {
		return x.UplinkEnabled
	}
	return false
}

func (x *ChannelSettings) GetDownlinkEnabled() bool {
	if x != nil {
		return x.DownlinkEnabled
	}
	return false
}

//
// The entire set of user settable/readable settings for our radio device.
// Includes both the current channel settings and any preferences the user has
// set for behavior of their node
type RadioConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Preferences *RadioConfig_UserPreferences `protobuf:"bytes,1,opt,name=preferences,proto3" json:"preferences,omitempty"`
	//
	// The preferred way to find channel settings is now in FromRadio.
	//
	// Deprecated: Do not use.
	ChannelSettings *ChannelSettings `protobuf:"bytes,2,opt,name=channel_settings,json=channelSettings,proto3" json:"channel_settings,omitempty"`
}

func (x *RadioConfig) Reset() {
	*x = RadioConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RadioConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RadioConfig) ProtoMessage() {}

func (x *RadioConfig) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RadioConfig.ProtoReflect.Descriptor instead.
func (*RadioConfig) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{7}
}

func (x *RadioConfig) GetPreferences() *RadioConfig_UserPreferences {
	if x != nil {
		return x.Preferences
	}
	return nil
}

// Deprecated: Do not use.
func (x *RadioConfig) GetChannelSettings() *ChannelSettings {
	if x != nil {
		return x.ChannelSettings
	}
	return nil
}

//
// The bluetooth to device link:
//
// Old BTLE protocol docs from TODO, merge in above and make real docs...
//
// use protocol buffers, and NanoPB
//
// messages from device to phone:
// POSITION_UPDATE (..., time)
// TEXT_RECEIVED(from, text, time)
// OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
//
// messages from phone to device:
// SET_MYID(id, human readable long, human readable short) (send down the unique ID
// string used for this node, a human readable string shown for that id, and a very
// short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
// (for signal messages or other applications) SEND_TEXT(dest, text) Get all
// nodes() (returns list of nodes, with full info, last time seen, loc, battery
// level etc) SET_CONFIG (switches device to a new set of radio params and
// preshared key, drops all existing nodes, force our node to rejoin this new group)
//
// Full information about a node on the mesh
type NodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// the node number
	Num uint32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	//
	// The user info for this node
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	//
	// This position data will also contain a time last seen
	Position *Position `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	//
	// Returns the Signal-to-noise ratio (SNR) of the last received message,
	// as measured by the receiver. Return SNR of the last received message in dB
	Snr float32 `protobuf:"fixed32,7,opt,name=snr,proto3" json:"snr,omitempty"`
	//
	// Returns the last measured frequency error.
	// The LoRa receiver estimates the frequency offset between the receiver
	// center frequency and that of the received LoRa signal. This function
	// returns the estimates offset (in Hz) of the last received message.
	// Caution: this measurement is not absolute, but is measured relative to the
	// local receiver's oscillator. Apparent errors may be due to the
	// transmitter, the receiver or both. \return The estimated center frequency
	// offset in Hz of the last received message.
	// int32 frequency_error = 6;
	//
	// enum RouteState {
	//  Invalid = 0;
	//  Discovering = 1;
	//  Valid = 2;
	// }
	//
	// Not needed?
	// RouteState route = 4;
	//
	// Our current preferred node node for routing - might be the same as num if
	// we are adjacent Or zero if we don't yet know a route to this node.
	NextHop uint32 `protobuf:"varint,5,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
}

func (x *NodeInfo) Reset() {
	*x = NodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo) ProtoMessage() {}

func (x *NodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{8}
}

func (x *NodeInfo) GetNum() uint32 {
	if x != nil {
		return x.Num
	}
	return 0
}

func (x *NodeInfo) GetUser() *User {
	if x != nil {
		return x.User
	}
	return nil
}

func (x *NodeInfo) GetPosition() *Position {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *NodeInfo) GetSnr() float32 {
	if x != nil {
		return x.Snr
	}
	return 0
}

func (x *NodeInfo) GetNextHop() uint32 {
	if x != nil {
		return x.NextHop
	}
	return 0
}

//
// Unique local debugging info for this node
// Note: we don't include position or the user info, because that will come in the
// Sent to the phone in response to WantNodes.
type MyNodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// Tells the phone what our node number is, default starting value is
	// lowbyte of macaddr, but it will be fixed if that is already in use
	MyNodeNum uint32 `protobuf:"varint,1,opt,name=my_node_num,json=myNodeNum,proto3" json:"my_node_num,omitempty"`
	//
	// Note: this bool no longer means "we have our own GPS".
	// Because gps_operation is more advanced, but we'd like old phone apps
	// to keep working.  So for legacy reasons we set this flag as follows:
	// if false it would be great if the phone can help provide gps coordinates.
	// If true we don't need location assistance from the phone.
	HasGps bool `protobuf:"varint,2,opt,name=has_gps,json=hasGps,proto3" json:"has_gps,omitempty"`
	//
	// # of legal channels (set at build time in the device flash image)
	NumChannels int32 `protobuf:"varint,3,opt,name=num_channels,json=numChannels,proto3" json:"num_channels,omitempty"`
	//
	// The region code for my radio (US, CN, etc...)
	// Note: This string is deprecated.  The 1.0 builds populate it based on the
	// flashed firmware name.  But for newer builds this string will be unpopulated
	// (missing/null).  For those builds you should instead look at the new
	// read/write region enum in UserSettings
	// The format of this string was 1.0-US or 1.0-CN etc.. Or empty string if unset.
	//
	// Deprecated: Do not use.
	Region string `protobuf:"bytes,4,opt,name=region,proto3" json:"region,omitempty"`
	//
	// TBEAM, HELTEC, etc...
	HwModel string `protobuf:"bytes,5,opt,name=hw_model,json=hwModel,proto3" json:"hw_model,omitempty"`
	//
	// 0.0.5 etc...
	FirmwareVersion string `protobuf:"bytes,6,opt,name=firmware_version,json=firmwareVersion,proto3" json:"firmware_version,omitempty"`
	//
	// An error message we'd like to report back to the mothership through analytics.
	// It indicates a serious bug occurred on the device, the device coped with it,
	// but we still want to tell the devs about the bug.
	// This field will be cleared after the phone reads MyNodeInfo
	// (i.e. it will only be reported once)
	// a numeric error code to go with error message, zero means no error
	ErrorCode CriticalErrorCode `protobuf:"varint,7,opt,name=error_code,json=errorCode,proto3,enum=CriticalErrorCode" json:"error_code,omitempty"`
	//
	// A numeric error address (nonzero if available)
	ErrorAddress uint32 `protobuf:"varint,8,opt,name=error_address,json=errorAddress,proto3" json:"error_address,omitempty"`
	//
	// The total number of errors this node has ever encountered
	// (well - since the last time we discarded preferences)
	ErrorCount uint32 `protobuf:"varint,9,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty"`
	//
	// How many bits are used for the packetid.  If zero it is assumed we use
	// eight bit packetids Old device loads (older that 0.6.5 do not populate this field,
	// but all newer loads do).
	PacketIdBits uint32 `protobuf:"varint,10,opt,name=packet_id_bits,json=packetIdBits,proto3" json:"packet_id_bits,omitempty"`
	//
	// This field was a bad idea - because the odds are so low of a collision API
	// clients should instead pick a randrom 32 bit number as their initial packetid and just keep
	// incrementing that.  Otherwise if a client connects two times in a row and used this
	// value (and the device had not sent a packet on its own between those two times) current_packet_id
	// would not have changed.  Then the client would be sending duplicate values.
	//
	// The current ID this node is using for sending new packets (exposed so that
	// the phone can self assign packet IDs if it wishes by picking packet IDs from
	// the opposite side of the pacekt ID space).
	// Old device loads (older that 0.6.5 do not populate this field, but all newer loads do).
	// FIXME: that we need to expose this is a bit of a mistake.  Really the phones
	// should be modeled/treated as 1st class nodes like any other, and the radio
	// connected to the phone just routes like any other. This would allow all sorts
	// of clean/clever routing topologies in the future.
	//
	// Deprecated: Do not use.
	CurrentPacketId uint32 `protobuf:"varint,11,opt,name=current_packet_id,json=currentPacketId,proto3" json:"current_packet_id,omitempty"`
	//
	// How many bits are used for the nodenum.  If zero it is assumed we use
	// eight bit nodenums New device loads will user 32 bit nodenum.
	// Old device loads (older that 0.6.5 do not populate this field, but all newer
	// loads do).
	NodeNumBits uint32 `protobuf:"varint,12,opt,name=node_num_bits,json=nodeNumBits,proto3" json:"node_num_bits,omitempty"`
	//
	// How long before we consider a message abandoned and we can clear our
	// caches of any messages in flight Normally quite large to handle the worst case
	// message delivery time, 5 minutes.  Formerly called FLOOD_EXPIRE_TIME in the
	// device code
	MessageTimeoutMsec uint32 `protobuf:"varint,13,opt,name=message_timeout_msec,json=messageTimeoutMsec,proto3" json:"message_timeout_msec,omitempty"`
	//
	// The minimum app version that can talk to this device.  Phone/PC apps should
	// compare this to their build number and if too low tell the user they must
	// update their app
	MinAppVersion uint32 `protobuf:"varint,14,opt,name=min_app_version,json=minAppVersion,proto3" json:"min_app_version,omitempty"`
}

func (x *MyNodeInfo) Reset() {
	*x = MyNodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MyNodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MyNodeInfo) ProtoMessage() {}

func (x *MyNodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MyNodeInfo.ProtoReflect.Descriptor instead.
func (*MyNodeInfo) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{9}
}

func (x *MyNodeInfo) GetMyNodeNum() uint32 {
	if x != nil {
		return x.MyNodeNum
	}
	return 0
}

func (x *MyNodeInfo) GetHasGps() bool {
	if x != nil {
		return x.HasGps
	}
	return false
}

func (x *MyNodeInfo) GetNumChannels() int32 {
	if x != nil {
		return x.NumChannels
	}
	return 0
}

// Deprecated: Do not use.
func (x *MyNodeInfo) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *MyNodeInfo) GetHwModel() string {
	if x != nil {
		return x.HwModel
	}
	return ""
}

func (x *MyNodeInfo) GetFirmwareVersion() string {
	if x != nil {
		return x.FirmwareVersion
	}
	return ""
}

func (x *MyNodeInfo) GetErrorCode() CriticalErrorCode {
	if x != nil {
		return x.ErrorCode
	}
	return CriticalErrorCode_None
}

func (x *MyNodeInfo) GetErrorAddress() uint32 {
	if x != nil {
		return x.ErrorAddress
	}
	return 0
}

func (x *MyNodeInfo) GetErrorCount() uint32 {
	if x != nil {
		return x.ErrorCount
	}
	return 0
}

func (x *MyNodeInfo) GetPacketIdBits() uint32 {
	if x != nil {
		return x.PacketIdBits
	}
	return 0
}

// Deprecated: Do not use.
func (x *MyNodeInfo) GetCurrentPacketId() uint32 {
	if x != nil {
		return x.CurrentPacketId
	}
	return 0
}

func (x *MyNodeInfo) GetNodeNumBits() uint32 {
	if x != nil {
		return x.NodeNumBits
	}
	return 0
}

func (x *MyNodeInfo) GetMessageTimeoutMsec() uint32 {
	if x != nil {
		return x.MessageTimeoutMsec
	}
	return 0
}

func (x *MyNodeInfo) GetMinAppVersion() uint32 {
	if x != nil {
		return x.MinAppVersion
	}
	return 0
}

// Debug output from the device.
//
// To minimize the size of records inside the device code, if a time/source/level is not set
// on the message it is assumed to be a continuation of the previously sent message.
// This allows the device code to use fixed maxlen 64 byte strings for messages,
// and then extend as needed by emitting multiple records.
type LogRecord struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	//
	// Seconds since 1970 - or 0 for unknown/unset
	Time uint32 `protobuf:"fixed32,2,opt,name=time,proto3" json:"time,omitempty"`
	//
	// Usually based on thread name - if known
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	//
	// Not yet set
	Level LogRecord_Level `protobuf:"varint,4,opt,name=level,proto3,enum=LogRecord_Level" json:"level,omitempty"`
}

func (x *LogRecord) Reset() {
	*x = LogRecord{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LogRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogRecord) ProtoMessage() {}

func (x *LogRecord) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogRecord.ProtoReflect.Descriptor instead.
func (*LogRecord) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{10}
}

func (x *LogRecord) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *LogRecord) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *LogRecord) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *LogRecord) GetLevel() LogRecord_Level {
	if x != nil {
		return x.Level
	}
	return LogRecord_UNSET
}

//
// Packets from the radio to the phone will appear on the fromRadio characteristic.
// It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
// It will sit in that descriptor until consumed by the phone,
// at which point the next item in the FIFO will be populated.
type FromRadio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// The packet num, used to allow the phone to request missing read packets from the FIFO,
	// see our bluetooth docs
	Num uint32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	// Types that are assignable to PayloadVariant:
	//	*FromRadio_Packet
	//	*FromRadio_MyInfo
	//	*FromRadio_NodeInfo
	//	*FromRadio_Radio
	//	*FromRadio_LogRecord
	//	*FromRadio_ConfigCompleteId
	//	*FromRadio_Rebooted
	//	*FromRadio_Channel
	PayloadVariant isFromRadio_PayloadVariant `protobuf_oneof:"payloadVariant"`
}

func (x *FromRadio) Reset() {
	*x = FromRadio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FromRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FromRadio) ProtoMessage() {}

func (x *FromRadio) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FromRadio.ProtoReflect.Descriptor instead.
func (*FromRadio) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{11}
}

func (x *FromRadio) GetNum() uint32 {
	if x != nil {
		return x.Num
	}
	return 0
}

func (m *FromRadio) GetPayloadVariant() isFromRadio_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *FromRadio) GetPacket() *MeshPacket {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Packet); ok {
		return x.Packet
	}
	return nil
}

func (x *FromRadio) GetMyInfo() *MyNodeInfo {
	if x, ok := x.GetPayloadVariant().(*FromRadio_MyInfo); ok {
		return x.MyInfo
	}
	return nil
}

func (x *FromRadio) GetNodeInfo() *NodeInfo {
	if x, ok := x.GetPayloadVariant().(*FromRadio_NodeInfo); ok {
		return x.NodeInfo
	}
	return nil
}

func (x *FromRadio) GetRadio() *RadioConfig {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Radio); ok {
		return x.Radio
	}
	return nil
}

func (x *FromRadio) GetLogRecord() *LogRecord {
	if x, ok := x.GetPayloadVariant().(*FromRadio_LogRecord); ok {
		return x.LogRecord
	}
	return nil
}

func (x *FromRadio) GetConfigCompleteId() uint32 {
	if x, ok := x.GetPayloadVariant().(*FromRadio_ConfigCompleteId); ok {
		return x.ConfigCompleteId
	}
	return 0
}

func (x *FromRadio) GetRebooted() bool {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Rebooted); ok {
		return x.Rebooted
	}
	return false
}

func (x *FromRadio) GetChannel() *ChannelSettings {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Channel); ok {
		return x.Channel
	}
	return nil
}

type isFromRadio_PayloadVariant interface {
	isFromRadio_PayloadVariant()
}

type FromRadio_Packet struct {
	Packet *MeshPacket `protobuf:"bytes,2,opt,name=packet,proto3,oneof"`
}

type FromRadio_MyInfo struct {
	//
	// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
	MyInfo *MyNodeInfo `protobuf:"bytes,3,opt,name=my_info,json=myInfo,proto3,oneof"`
}

type FromRadio_NodeInfo struct {
	//
	// One packet is sent for each node in the on radio DB
	// starts over with the first node in our DB
	NodeInfo *NodeInfo `protobuf:"bytes,4,opt,name=node_info,json=nodeInfo,proto3,oneof"`
}

type FromRadio_Radio struct {
	//
	// In rev1 this was the radio BLE characteristic
	Radio *RadioConfig `protobuf:"bytes,6,opt,name=radio,proto3,oneof"`
}

type FromRadio_LogRecord struct {
	//
	// set to send debug console output over our protobuf stream
	LogRecord *LogRecord `protobuf:"bytes,7,opt,name=log_record,json=logRecord,proto3,oneof"`
}

type FromRadio_ConfigCompleteId struct {
	//
	// sent as true once the device has finished sending all of the responses to want_config
	// recipient should check if this ID matches our original request nonce, if
	// not, it means your config responses haven't started yet.
	ConfigCompleteId uint32 `protobuf:"varint,8,opt,name=config_complete_id,json=configCompleteId,proto3,oneof"`
}

type FromRadio_Rebooted struct {
	//
	// Sent to tell clients the radio has just rebooted.  Set to true if present.
	// Not used on all transports, currently just used for the serial console.
	Rebooted bool `protobuf:"varint,9,opt,name=rebooted,proto3,oneof"`
}

type FromRadio_Channel struct {
	//
	// One of the channels, they are all sent during config download
	// The first channel is the "primary" channel all other channels are secondary channels
	// The primary channel is also sent as part of RadioConfig
	// (which is deprecated, but to support older clients)
	Channel *ChannelSettings `protobuf:"bytes,10,opt,name=channel,proto3,oneof"`
}

func (*FromRadio_Packet) isFromRadio_PayloadVariant() {}

func (*FromRadio_MyInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_NodeInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_Radio) isFromRadio_PayloadVariant() {}

func (*FromRadio_LogRecord) isFromRadio_PayloadVariant() {}

func (*FromRadio_ConfigCompleteId) isFromRadio_PayloadVariant() {}

func (*FromRadio_Rebooted) isFromRadio_PayloadVariant() {}

func (*FromRadio_Channel) isFromRadio_PayloadVariant() {}

//
// packets/commands to the radio will be written (reliably) to the toRadio characteristic.
// Once the write completes the phone can assume it is handled.
type ToRadio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to PayloadVariant:
	//	*ToRadio_Packet
	//	*ToRadio_WantConfigId
	//	*ToRadio_SetRadio
	//	*ToRadio_SetOwner
	//	*ToRadio_SetChannel
	PayloadVariant isToRadio_PayloadVariant `protobuf_oneof:"payloadVariant"`
}

func (x *ToRadio) Reset() {
	*x = ToRadio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ToRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToRadio) ProtoMessage() {}

func (x *ToRadio) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToRadio.ProtoReflect.Descriptor instead.
func (*ToRadio) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{12}
}

func (m *ToRadio) GetPayloadVariant() isToRadio_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *ToRadio) GetPacket() *MeshPacket {
	if x, ok := x.GetPayloadVariant().(*ToRadio_Packet); ok {
		return x.Packet
	}
	return nil
}

func (x *ToRadio) GetWantConfigId() uint32 {
	if x, ok := x.GetPayloadVariant().(*ToRadio_WantConfigId); ok {
		return x.WantConfigId
	}
	return 0
}

func (x *ToRadio) GetSetRadio() *RadioConfig {
	if x, ok := x.GetPayloadVariant().(*ToRadio_SetRadio); ok {
		return x.SetRadio
	}
	return nil
}

func (x *ToRadio) GetSetOwner() *User {
	if x, ok := x.GetPayloadVariant().(*ToRadio_SetOwner); ok {
		return x.SetOwner
	}
	return nil
}

func (x *ToRadio) GetSetChannel() *ChannelSettings {
	if x, ok := x.GetPayloadVariant().(*ToRadio_SetChannel); ok {
		return x.SetChannel
	}
	return nil
}

type isToRadio_PayloadVariant interface {
	isToRadio_PayloadVariant()
}

type ToRadio_Packet struct {
	//
	// send this packet on the mesh
	Packet *MeshPacket `protobuf:"bytes,1,opt,name=packet,proto3,oneof"`
}

type ToRadio_WantConfigId struct {
	//
	// phone wants radio to send full node db to the phone, This is
	// typically the first packet sent to the radio when the phone gets a
	// bluetooth connection. The radio will respond by sending back a
	// MyNodeInfo, a owner, a radio config and a series of
	// FromRadio.node_infos, and config_complete
	// the integer you write into this field will be reported back in the
	// config_complete_id response this allows clients to never be confused by
	// a stale old partially sent config.
	WantConfigId uint32 `protobuf:"varint,100,opt,name=want_config_id,json=wantConfigId,proto3,oneof"`
}

type ToRadio_SetRadio struct {
	//
	// set the radio provisioning for this node
	SetRadio *RadioConfig `protobuf:"bytes,101,opt,name=set_radio,json=setRadio,proto3,oneof"`
}

type ToRadio_SetOwner struct {
	//
	// Set the owner for this node
	SetOwner *User `protobuf:"bytes,102,opt,name=set_owner,json=setOwner,proto3,oneof"`
}

type ToRadio_SetChannel struct {
	//
	// Set channels (using the new API).  The first sent channel is assumed to be channel
	// index 0 the "primary channel".  Following records are secondary channels.
	SetChannel *ChannelSettings `protobuf:"bytes,103,opt,name=set_channel,json=setChannel,proto3,oneof"`
}

func (*ToRadio_Packet) isToRadio_PayloadVariant() {}

func (*ToRadio_WantConfigId) isToRadio_PayloadVariant() {}

func (*ToRadio_SetRadio) isToRadio_PayloadVariant() {}

func (*ToRadio_SetOwner) isToRadio_PayloadVariant() {}

func (*ToRadio_SetChannel) isToRadio_PayloadVariant() {}

//
// see sw-design.md for more information on these preferences
type RadioConfig_UserPreferences struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// We should send our position this often (but only if it has changed significantly)
	// Defaults to 15 minutes
	PositionBroadcastSecs uint32 `protobuf:"varint,1,opt,name=position_broadcast_secs,json=positionBroadcastSecs,proto3" json:"position_broadcast_secs,omitempty"`
	//
	// Send our owner info at least this often (also we always send once at boot - to rejoin the mesh)
	SendOwnerInterval uint32 `protobuf:"varint,2,opt,name=send_owner_interval,json=sendOwnerInterval,proto3" json:"send_owner_interval,omitempty"`
	//
	// Power management state machine option.
	// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
	// 0 for default of 1 minute
	WaitBluetoothSecs uint32 `protobuf:"varint,4,opt,name=wait_bluetooth_secs,json=waitBluetoothSecs,proto3" json:"wait_bluetooth_secs,omitempty"`
	//
	// Power management state machine option.
	// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
	// 0 for default of one minute
	ScreenOnSecs uint32 `protobuf:"varint,5,opt,name=screen_on_secs,json=screenOnSecs,proto3" json:"screen_on_secs,omitempty"`
	//
	// Power management state machine option.
	// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
	// 0 for default of 15 minutes
	PhoneTimeoutSecs uint32 `protobuf:"varint,6,opt,name=phone_timeout_secs,json=phoneTimeoutSecs,proto3" json:"phone_timeout_secs,omitempty"`
	//
	// Power management state machine option.
	// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
	// 0 for default of two hours, MAXUINT for disabled
	PhoneSdsTimeoutSec uint32 `protobuf:"varint,7,opt,name=phone_sds_timeout_sec,json=phoneSdsTimeoutSec,proto3" json:"phone_sds_timeout_sec,omitempty"`
	//
	// Power management state machine option.
	// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
	// 0 for default of two hours, MAXUINT for disabled
	MeshSdsTimeoutSecs uint32 `protobuf:"varint,8,opt,name=mesh_sds_timeout_secs,json=meshSdsTimeoutSecs,proto3" json:"mesh_sds_timeout_secs,omitempty"`
	//
	// Power management state machine option.
	// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
	// 0 for default of one year
	SdsSecs uint32 `protobuf:"varint,9,opt,name=sds_secs,json=sdsSecs,proto3" json:"sds_secs,omitempty"`
	//
	// Power management state machine option.
	// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
	// 0 for default of 3600
	LsSecs uint32 `protobuf:"varint,10,opt,name=ls_secs,json=lsSecs,proto3" json:"ls_secs,omitempty"`
	//
	// Power management state machine option.
	// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
	// 0 for default of 10 seconds
	MinWakeSecs uint32 `protobuf:"varint,11,opt,name=min_wake_secs,json=minWakeSecs,proto3" json:"min_wake_secs,omitempty"`
	// If set, this node will try to join the specified wifi network and
	// acquire an address via DHCP
	WifiSsid string `protobuf:"bytes,12,opt,name=wifi_ssid,json=wifiSsid,proto3" json:"wifi_ssid,omitempty"`
	//
	// If set, will be use to authenticate to the named wifi
	WifiPassword string `protobuf:"bytes,13,opt,name=wifi_password,json=wifiPassword,proto3" json:"wifi_password,omitempty"`
	//
	// If set, the node will operate as an AP (and DHCP server), otherwise it
	// will be a station
	WifiApMode bool `protobuf:"varint,14,opt,name=wifi_ap_mode,json=wifiApMode,proto3" json:"wifi_ap_mode,omitempty"`
	//
	// The region code for my radio (US, CN, EU433, etc...)
	Region RegionCode `protobuf:"varint,15,opt,name=region,proto3,enum=RegionCode" json:"region,omitempty"`
	//
	// Sets the current of the battery charger
	ChargeCurrent ChargeCurrent `protobuf:"varint,16,opt,name=charge_current,json=chargeCurrent,proto3,enum=ChargeCurrent" json:"charge_current,omitempty"`
	//
	// Are we operating as a router.  Changes behavior in the following ways:
	// The device will only sleep for critically low battery level (i.e. always tries to stay alive for the mesh)
	// In the future routing decisions will preferentially route packets through nodes with this attribute (because assumed
	// good line of sight)
	IsRouter bool `protobuf:"varint,37,opt,name=is_router,json=isRouter,proto3" json:"is_router,omitempty"`
	//
	// If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
	// we should try to minimize power consumption as much as possible.  YOU DO NOT NEED TO SET THIS IF YOU'VE
	// set is_router (it is implied in that case).
	IsLowPower bool `protobuf:"varint,38,opt,name=is_low_power,json=isLowPower,proto3" json:"is_low_power,omitempty"`
	//
	// If set, this node is at a fixed position.  We will generate GPS position updates
	// at the regular interval, but use whatever the last lat/lon/alt we have for the node.
	// The lat/lon/alt can be set by an internal GPS or with the help of the app.
	FixedPosition bool `protobuf:"varint,39,opt,name=fixed_position,json=fixedPosition,proto3" json:"fixed_position,omitempty"`
	//
	// This setting is never saved to disk, but if set, all device settings will be
	// returned to factory defaults.  (Region, serial number etc... will be preserved)
	FactoryReset bool `protobuf:"varint,100,opt,name=factory_reset,json=factoryReset,proto3" json:"factory_reset,omitempty"`
	//
	// By default we turn off logging as soon as an API client connects (to keep
	// shared serial link quiet).  Set this to true to leave the debug log outputting even when API is active.
	DebugLogEnabled bool `protobuf:"varint,101,opt,name=debug_log_enabled,json=debugLogEnabled,proto3" json:"debug_log_enabled,omitempty"`
	//*
	//How our location is shared with other nodes (or the local phone)
	LocationShare LocationSharing `protobuf:"varint,32,opt,name=location_share,json=locationShare,proto3,enum=LocationSharing" json:"location_share,omitempty"`
	//
	// How the GPS hardware in this unit is operated.
	// Note: This is independent of how our location is shared with other devices.  For that see LocationSharing
	GpsOperation GpsOperation `protobuf:"varint,33,opt,name=gps_operation,json=gpsOperation,proto3,enum=GpsOperation" json:"gps_operation,omitempty"`
	//
	// How often should we try to get GPS position (in seconds) when we are in GpsOpMobile mode?
	// or zero for the default of once every 30 seconds
	// or a very large value (maxint) to update only once at boot.
	GpsUpdateInterval uint32 `protobuf:"varint,34,opt,name=gps_update_interval,json=gpsUpdateInterval,proto3" json:"gps_update_interval,omitempty"`
	//
	// How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
	// Or if zero, use the default of 30 seconds.
	// If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
	// window.
	GpsAttemptTime uint32 `protobuf:"varint,36,opt,name=gps_attempt_time,json=gpsAttemptTime,proto3" json:"gps_attempt_time,omitempty"`
	//
	// If true, radio should not try to be smart about what packets to queue to
	// the phone
	// bool keep_all_packets = 101;
	//
	// If true, we will try to capture all the packets sent on the mesh, not
	// just the ones destined to our node.
	// bool promiscuous_mode = 102;
	//
	// For testing it is useful sometimes to force a node to never listen to
	// particular other nodes (simulating radio out of range). All nodenums listed
	// in ignore_incoming will have packets they send droped on receive (by router.cpp)
	IgnoreIncoming []uint32 `protobuf:"varint,103,rep,packed,name=ignore_incoming,json=ignoreIncoming,proto3" json:"ignore_incoming,omitempty"`
	//*
	//Preferences for the SerialPlugin
	//
	//FIXME - Move this out of UserPreferences and into a section for plugin configuration.
	SerialpluginEnabled bool   `protobuf:"varint,120,opt,name=serialplugin_enabled,json=serialpluginEnabled,proto3" json:"serialplugin_enabled,omitempty"`
	SerialpluginEcho    bool   `protobuf:"varint,121,opt,name=serialplugin_echo,json=serialpluginEcho,proto3" json:"serialplugin_echo,omitempty"`
	SerialpluginRxd     uint32 `protobuf:"varint,122,opt,name=serialplugin_rxd,json=serialpluginRxd,proto3" json:"serialplugin_rxd,omitempty"`
	SerialpluginTxd     uint32 `protobuf:"varint,123,opt,name=serialplugin_txd,json=serialpluginTxd,proto3" json:"serialplugin_txd,omitempty"`
	SerialpluginTimeout uint32 `protobuf:"varint,124,opt,name=serialplugin_timeout,json=serialpluginTimeout,proto3" json:"serialplugin_timeout,omitempty"`
	SerialpluginMode    uint32 `protobuf:"varint,125,opt,name=serialplugin_mode,json=serialpluginMode,proto3" json:"serialplugin_mode,omitempty"`
	//*
	//Preferences for the ExternalNotificationPlugin
	//
	//FIXME - Move this out of UserPreferences and into a section for plugin configuration.
	ExtNotificationPluginEnabled      bool   `protobuf:"varint,126,opt,name=ext_notification_plugin_enabled,json=extNotificationPluginEnabled,proto3" json:"ext_notification_plugin_enabled,omitempty"`
	ExtNotificationPluginOutputMs     uint32 `protobuf:"varint,127,opt,name=ext_notification_plugin_output_ms,json=extNotificationPluginOutputMs,proto3" json:"ext_notification_plugin_output_ms,omitempty"`
	ExtNotificationPluginOutput       uint32 `protobuf:"varint,128,opt,name=ext_notification_plugin_output,json=extNotificationPluginOutput,proto3" json:"ext_notification_plugin_output,omitempty"`
	ExtNotificationPluginActive       bool   `protobuf:"varint,129,opt,name=ext_notification_plugin_active,json=extNotificationPluginActive,proto3" json:"ext_notification_plugin_active,omitempty"`
	ExtNotificationPluginAlertMessage bool   `protobuf:"varint,130,opt,name=ext_notification_plugin_alert_message,json=extNotificationPluginAlertMessage,proto3" json:"ext_notification_plugin_alert_message,omitempty"`
	ExtNotificationPluginAlertBell    bool   `protobuf:"varint,131,opt,name=ext_notification_plugin_alert_bell,json=extNotificationPluginAlertBell,proto3" json:"ext_notification_plugin_alert_bell,omitempty"`
	//*
	//Preferences for the RangeTestPlugin
	//
	//FIXME - Move this out of UserPreferences and into a section for plugin configuration.
	RangeTestPluginEnabled bool   `protobuf:"varint,132,opt,name=range_test_plugin_enabled,json=rangeTestPluginEnabled,proto3" json:"range_test_plugin_enabled,omitempty"`
	RangeTestPluginSender  uint32 `protobuf:"varint,133,opt,name=range_test_plugin_sender,json=rangeTestPluginSender,proto3" json:"range_test_plugin_sender,omitempty"`
	RangeTestPluginSave    bool   `protobuf:"varint,134,opt,name=range_test_plugin_save,json=rangeTestPluginSave,proto3" json:"range_test_plugin_save,omitempty"`
	//*
	//Preferences for the StoreForwardPlugin
	//
	//FIXME - Move this out of UserPreferences and into a section for plugin configuration.
	StoreForwardPluginEnabled bool   `protobuf:"varint,136,opt,name=store_forward_plugin_enabled,json=storeForwardPluginEnabled,proto3" json:"store_forward_plugin_enabled,omitempty"`
	StoreForwardPluginRecords uint32 `protobuf:"varint,137,opt,name=store_forward_plugin_records,json=storeForwardPluginRecords,proto3" json:"store_forward_plugin_records,omitempty"`
	//
	// Enable/Disable the environmental measurement plugin measurement collection
	EnvironmentalMeasurementPluginMeasurementEnabled bool `protobuf:"varint,140,opt,name=environmental_measurement_plugin_measurement_enabled,json=environmentalMeasurementPluginMeasurementEnabled,proto3" json:"environmental_measurement_plugin_measurement_enabled,omitempty"`
	//
	// Enable/Disable the environmental measurement plugin on-device display
	EnvironmentalMeasurementPluginScreenEnabled bool `protobuf:"varint,141,opt,name=environmental_measurement_plugin_screen_enabled,json=environmentalMeasurementPluginScreenEnabled,proto3" json:"environmental_measurement_plugin_screen_enabled,omitempty"`
	//
	// Sometimes sensor reads can fail.  If this happens, we
	// will retry a configurable number of attempts
	// Each attempt will be delayed by the minimum
	// required refresh rate for that sensor
	EnvironmentalMeasurementPluginReadErrorCountThreshold uint32 `protobuf:"varint,142,opt,name=environmental_measurement_plugin_read_error_count_threshold,json=environmentalMeasurementPluginReadErrorCountThreshold,proto3" json:"environmental_measurement_plugin_read_error_count_threshold,omitempty"`
	//
	// Interval in seconds of how often we should try to send our
	// measurements to the mesh
	EnvironmentalMeasurementPluginUpdateInterval uint32 `protobuf:"varint,143,opt,name=environmental_measurement_plugin_update_interval,json=environmentalMeasurementPluginUpdateInterval,proto3" json:"environmental_measurement_plugin_update_interval,omitempty"`
	// Sometimes we can end up with more than read_error_count_threshold
	// failures.  In this case, we will stop trying to read from the sensor
	// for a while.  Wait this long until trying to read from the sensor again
	EnvironmentalMeasurementPluginRecoveryInterval uint32 `protobuf:"varint,144,opt,name=environmental_measurement_plugin_recovery_interval,json=environmentalMeasurementPluginRecoveryInterval,proto3" json:"environmental_measurement_plugin_recovery_interval,omitempty"`
}

func (x *RadioConfig_UserPreferences) Reset() {
	*x = RadioConfig_UserPreferences{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RadioConfig_UserPreferences) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RadioConfig_UserPreferences) ProtoMessage() {}

func (x *RadioConfig_UserPreferences) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RadioConfig_UserPreferences.ProtoReflect.Descriptor instead.
func (*RadioConfig_UserPreferences) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{7, 0}
}

func (x *RadioConfig_UserPreferences) GetPositionBroadcastSecs() uint32 {
	if x != nil {
		return x.PositionBroadcastSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetSendOwnerInterval() uint32 {
	if x != nil {
		return x.SendOwnerInterval
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetWaitBluetoothSecs() uint32 {
	if x != nil {
		return x.WaitBluetoothSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetScreenOnSecs() uint32 {
	if x != nil {
		return x.ScreenOnSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetPhoneTimeoutSecs() uint32 {
	if x != nil {
		return x.PhoneTimeoutSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetPhoneSdsTimeoutSec() uint32 {
	if x != nil {
		return x.PhoneSdsTimeoutSec
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetMeshSdsTimeoutSecs() uint32 {
	if x != nil {
		return x.MeshSdsTimeoutSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetSdsSecs() uint32 {
	if x != nil {
		return x.SdsSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetLsSecs() uint32 {
	if x != nil {
		return x.LsSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetMinWakeSecs() uint32 {
	if x != nil {
		return x.MinWakeSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetWifiSsid() string {
	if x != nil {
		return x.WifiSsid
	}
	return ""
}

func (x *RadioConfig_UserPreferences) GetWifiPassword() string {
	if x != nil {
		return x.WifiPassword
	}
	return ""
}

func (x *RadioConfig_UserPreferences) GetWifiApMode() bool {
	if x != nil {
		return x.WifiApMode
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetRegion() RegionCode {
	if x != nil {
		return x.Region
	}
	return RegionCode_Unset
}

func (x *RadioConfig_UserPreferences) GetChargeCurrent() ChargeCurrent {
	if x != nil {
		return x.ChargeCurrent
	}
	return ChargeCurrent_MAUnset
}

func (x *RadioConfig_UserPreferences) GetIsRouter() bool {
	if x != nil {
		return x.IsRouter
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetIsLowPower() bool {
	if x != nil {
		return x.IsLowPower
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetFixedPosition() bool {
	if x != nil {
		return x.FixedPosition
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetFactoryReset() bool {
	if x != nil {
		return x.FactoryReset
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetDebugLogEnabled() bool {
	if x != nil {
		return x.DebugLogEnabled
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetLocationShare() LocationSharing {
	if x != nil {
		return x.LocationShare
	}
	return LocationSharing_LocUnset
}

func (x *RadioConfig_UserPreferences) GetGpsOperation() GpsOperation {
	if x != nil {
		return x.GpsOperation
	}
	return GpsOperation_GpsOpUnset
}

func (x *RadioConfig_UserPreferences) GetGpsUpdateInterval() uint32 {
	if x != nil {
		return x.GpsUpdateInterval
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetGpsAttemptTime() uint32 {
	if x != nil {
		return x.GpsAttemptTime
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetIgnoreIncoming() []uint32 {
	if x != nil {
		return x.IgnoreIncoming
	}
	return nil
}

func (x *RadioConfig_UserPreferences) GetSerialpluginEnabled() bool {
	if x != nil {
		return x.SerialpluginEnabled
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetSerialpluginEcho() bool {
	if x != nil {
		return x.SerialpluginEcho
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetSerialpluginRxd() uint32 {
	if x != nil {
		return x.SerialpluginRxd
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetSerialpluginTxd() uint32 {
	if x != nil {
		return x.SerialpluginTxd
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetSerialpluginTimeout() uint32 {
	if x != nil {
		return x.SerialpluginTimeout
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetSerialpluginMode() uint32 {
	if x != nil {
		return x.SerialpluginMode
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetExtNotificationPluginEnabled() bool {
	if x != nil {
		return x.ExtNotificationPluginEnabled
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetExtNotificationPluginOutputMs() uint32 {
	if x != nil {
		return x.ExtNotificationPluginOutputMs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetExtNotificationPluginOutput() uint32 {
	if x != nil {
		return x.ExtNotificationPluginOutput
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetExtNotificationPluginActive() bool {
	if x != nil {
		return x.ExtNotificationPluginActive
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetExtNotificationPluginAlertMessage() bool {
	if x != nil {
		return x.ExtNotificationPluginAlertMessage
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetExtNotificationPluginAlertBell() bool {
	if x != nil {
		return x.ExtNotificationPluginAlertBell
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetRangeTestPluginEnabled() bool {
	if x != nil {
		return x.RangeTestPluginEnabled
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetRangeTestPluginSender() uint32 {
	if x != nil {
		return x.RangeTestPluginSender
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetRangeTestPluginSave() bool {
	if x != nil {
		return x.RangeTestPluginSave
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetStoreForwardPluginEnabled() bool {
	if x != nil {
		return x.StoreForwardPluginEnabled
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetStoreForwardPluginRecords() uint32 {
	if x != nil {
		return x.StoreForwardPluginRecords
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetEnvironmentalMeasurementPluginMeasurementEnabled() bool {
	if x != nil {
		return x.EnvironmentalMeasurementPluginMeasurementEnabled
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetEnvironmentalMeasurementPluginScreenEnabled() bool {
	if x != nil {
		return x.EnvironmentalMeasurementPluginScreenEnabled
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetEnvironmentalMeasurementPluginReadErrorCountThreshold() uint32 {
	if x != nil {
		return x.EnvironmentalMeasurementPluginReadErrorCountThreshold
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetEnvironmentalMeasurementPluginUpdateInterval() uint32 {
	if x != nil {
		return x.EnvironmentalMeasurementPluginUpdateInterval
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetEnvironmentalMeasurementPluginRecoveryInterval() uint32 {
	if x != nil {
		return x.EnvironmentalMeasurementPluginRecoveryInterval
	}
	return 0
}

var File_mesh_proto protoreflect.FileDescriptor

var file_mesh_proto_rawDesc = []byte{
	0x0a, 0x0a, 0x6d, 0x65, 0x73, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x0e, 0x70, 0x6f,
	0x72, 0x74, 0x6e, 0x75, 0x6d, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x9f, 0x01, 0x0a,
	0x08, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x6c, 0x61, 0x74,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18, 0x07, 0x20, 0x01, 0x28, 0x11, 0x52, 0x09, 0x6c,
	0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x49, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x6f, 0x6e, 0x67,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18, 0x08, 0x20, 0x01, 0x28, 0x11, 0x52, 0x0a, 0x6c,
	0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x49, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x6c, 0x74,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x61, 0x6c, 0x74,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79,
	0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x62, 0x61,
	0x74, 0x74, 0x65, 0x72, 0x79, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x69,
	0x6d, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x22, 0x44,
	0x0a, 0x04, 0x44, 0x61, 0x74, 0x61, 0x12, 0x22, 0x0a, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x6e, 0x75,
	0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x08, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x4e, 0x75,
	0x6d, 0x52, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x6e, 0x75, 0x6d, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61,
	0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x70, 0x61, 0x79,
	0x6c, 0x6f, 0x61, 0x64, 0x22, 0x6c, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1b, 0x0a, 0x09,
	0x6c, 0x6f, 0x6e, 0x67, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x08, 0x6c, 0x6f, 0x6e, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x68, 0x6f,
	0x72, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73,
	0x68, 0x6f, 0x72, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x61, 0x63, 0x61,
	0x64, 0x64, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x6d, 0x61, 0x63, 0x61, 0x64,
	0x64, 0x72, 0x22, 0x26, 0x0a, 0x0e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63, 0x6f,
	0x76, 0x65, 0x72, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x05, 0x52, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x22, 0xe3, 0x03, 0x0a, 0x09, 0x53,
	0x75, 0x62, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x1b, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x05, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x48, 0x00, 0x52,
	0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x36, 0x0a, 0x0d, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x72,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x48, 0x00, 0x52,
	0x0c, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x32, 0x0a,
	0x0b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76,
	0x65, 0x72, 0x79, 0x48, 0x00, 0x52, 0x0a, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x70, 0x6c,
	0x79, 0x12, 0x31, 0x0a, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x72, 0x65, 0x61, 0x73, 0x6f,
	0x6e, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0c, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x52,
	0x65, 0x61, 0x73, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x0b, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x52, 0x65,
	0x61, 0x73, 0x6f, 0x6e, 0x12, 0x2b, 0x0a, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x09, 0x2e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x42, 0x02, 0x18, 0x01, 0x48, 0x00, 0x52, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x1f, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x05, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x42, 0x02, 0x18, 0x01, 0x48, 0x00, 0x52, 0x04, 0x75, 0x73,
	0x65, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x77, 0x61, 0x6e, 0x74, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x77, 0x61, 0x6e, 0x74, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1f, 0x0a, 0x0a, 0x73, 0x75, 0x63, 0x63, 0x65,
	0x73, 0x73, 0x5f, 0x69, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x01, 0x52, 0x09, 0x73,
	0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x07, 0x66, 0x61, 0x69, 0x6c,
	0x5f, 0x69, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x01, 0x52, 0x06, 0x66, 0x61, 0x69,
	0x6c, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x65, 0x73, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x04, 0x64, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63,
	0x65, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12,
	0x1f, 0x0a, 0x0b, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x49, 0x64,
	0x42, 0x10, 0x0a, 0x0e, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x56, 0x61, 0x72, 0x69, 0x61,
	0x6e, 0x74, 0x42, 0x0c, 0x0a, 0x0a, 0x61, 0x63, 0x6b, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74,
	0x22, 0xb6, 0x03, 0x0a, 0x0a, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12,
	0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x66,
	0x72, 0x6f, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x74, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x02, 0x74, 0x6f, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69,
	0x6e, 0x64, 0x65, 0x78, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x63, 0x68, 0x61, 0x6e,
	0x6e, 0x65, 0x6c, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x26, 0x0a, 0x07, 0x64, 0x65, 0x63, 0x6f,
	0x64, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x53, 0x75, 0x62, 0x50,
	0x61, 0x63, 0x6b, 0x65, 0x74, 0x48, 0x00, 0x52, 0x07, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x64,
	0x12, 0x1e, 0x0a, 0x09, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x09, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64,
	0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x64,
	0x12, 0x17, 0x0a, 0x07, 0x72, 0x78, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x07, 0x52, 0x06, 0x72, 0x78, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x72, 0x78, 0x5f,
	0x73, 0x6e, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x02, 0x52, 0x05, 0x72, 0x78, 0x53, 0x6e, 0x72,
	0x12, 0x1b, 0x0a, 0x09, 0x68, 0x6f, 0x70, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x0a, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x08, 0x68, 0x6f, 0x70, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x19, 0x0a,
	0x08, 0x77, 0x61, 0x6e, 0x74, 0x5f, 0x61, 0x63, 0x6b, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x07, 0x77, 0x61, 0x6e, 0x74, 0x41, 0x63, 0x6b, 0x12, 0x30, 0x0a, 0x08, 0x70, 0x72, 0x69, 0x6f,
	0x72, 0x69, 0x74, 0x79, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x14, 0x2e, 0x4d, 0x65, 0x73,
	0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x2e, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79,
	0x52, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x22, 0x5b, 0x0a, 0x08, 0x50, 0x72,
	0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x12, 0x09, 0x0a, 0x05, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10,
	0x00, 0x12, 0x07, 0x0a, 0x03, 0x4d, 0x49, 0x4e, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x42, 0x41,
	0x43, 0x4b, 0x47, 0x52, 0x4f, 0x55, 0x4e, 0x44, 0x10, 0x0a, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x45,
	0x46, 0x41, 0x55, 0x4c, 0x54, 0x10, 0x40, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x45, 0x4c, 0x49, 0x41,
	0x42, 0x4c, 0x45, 0x10, 0x46, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x43, 0x4b, 0x10, 0x78, 0x12, 0x07,
	0x0a, 0x03, 0x4d, 0x41, 0x58, 0x10, 0x7f, 0x42, 0x10, 0x0a, 0x0e, 0x70, 0x61, 0x79, 0x6c, 0x6f,
	0x61, 0x64, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0xdc, 0x03, 0x0a, 0x0f, 0x43, 0x68,
	0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x12, 0x19, 0x0a,
	0x08, 0x74, 0x78, 0x5f, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x07, 0x74, 0x78, 0x50, 0x6f, 0x77, 0x65, 0x72, 0x12, 0x3f, 0x0a, 0x0c, 0x6d, 0x6f, 0x64, 0x65,
	0x6d, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1c,
	0x2e, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73,
	0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0b, 0x6d, 0x6f,
	0x64, 0x65, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1c, 0x0a, 0x09, 0x62, 0x61, 0x6e,
	0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x62, 0x61,
	0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x23, 0x0a, 0x0d, 0x73, 0x70, 0x72, 0x65, 0x61,
	0x64, 0x5f, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c,
	0x73, 0x70, 0x72, 0x65, 0x61, 0x64, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x1f, 0x0a, 0x0b,
	0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x0a, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x61, 0x74, 0x65, 0x12, 0x1f, 0x0a,
	0x0b, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x09, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x0a, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x4e, 0x75, 0x6d, 0x12, 0x10,
	0x0a, 0x03, 0x70, 0x73, 0x6b, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x03, 0x70, 0x73, 0x6b,
	0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x6e, 0x61, 0x6d, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x07,
	0x52, 0x02, 0x69, 0x64, 0x12, 0x25, 0x0a, 0x0e, 0x75, 0x70, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x65,
	0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x10, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x75, 0x70,
	0x6c, 0x69, 0x6e, 0x6b, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x29, 0x0a, 0x10, 0x64,
	0x6f, 0x77, 0x6e, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18,
	0x11, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x69, 0x6e, 0x6b, 0x45,
	0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22, 0x60, 0x0a, 0x0b, 0x4d, 0x6f, 0x64, 0x65, 0x6d, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x0e, 0x42, 0x77, 0x31, 0x32, 0x35, 0x43, 0x72,
	0x34, 0x35, 0x53, 0x66, 0x31, 0x32, 0x38, 0x10, 0x00, 0x12, 0x12, 0x0a, 0x0e, 0x42, 0x77, 0x35,
	0x30, 0x30, 0x43, 0x72, 0x34, 0x35, 0x53, 0x66, 0x31, 0x32, 0x38, 0x10, 0x01, 0x12, 0x14, 0x0a,
	0x10, 0x42, 0x77, 0x33, 0x31, 0x5f, 0x32, 0x35, 0x43, 0x72, 0x34, 0x38, 0x53, 0x66, 0x35, 0x31,
	0x32, 0x10, 0x02, 0x12, 0x13, 0x0a, 0x0f, 0x42, 0x77, 0x31, 0x32, 0x35, 0x43, 0x72, 0x34, 0x38,
	0x53, 0x66, 0x34, 0x30, 0x39, 0x36, 0x10, 0x03, 0x22, 0xe1, 0x15, 0x0a, 0x0b, 0x52, 0x61, 0x64,
	0x69, 0x6f, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x3e, 0x0a, 0x0b, 0x70, 0x72, 0x65, 0x66,
	0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e,
	0x52, 0x61, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x55, 0x73, 0x65, 0x72,
	0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x0b, 0x70, 0x72, 0x65,
	0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x3f, 0x0a, 0x10, 0x63, 0x68, 0x61, 0x6e,
	0x6e, 0x65, 0x6c, 0x5f, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x10, 0x2e, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x65, 0x74, 0x74,
	0x69, 0x6e, 0x67, 0x73, 0x42, 0x02, 0x18, 0x01, 0x52, 0x0f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
	0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x1a, 0xd0, 0x14, 0x0a, 0x0f, 0x55, 0x73,
	0x65, 0x72, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x36, 0x0a,
	0x17, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x62, 0x72, 0x6f, 0x61, 0x64, 0x63,
	0x61, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x15,
	0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73,
	0x74, 0x53, 0x65, 0x63, 0x73, 0x12, 0x2e, 0x0a, 0x13, 0x73, 0x65, 0x6e, 0x64, 0x5f, 0x6f, 0x77,
	0x6e, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x11, 0x73, 0x65, 0x6e, 0x64, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x74,
	0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x2e, 0x0a, 0x13, 0x77, 0x61, 0x69, 0x74, 0x5f, 0x62, 0x6c,
	0x75, 0x65, 0x74, 0x6f, 0x6f, 0x74, 0x68, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x11, 0x77, 0x61, 0x69, 0x74, 0x42, 0x6c, 0x75, 0x65, 0x74, 0x6f, 0x6f, 0x74,
	0x68, 0x53, 0x65, 0x63, 0x73, 0x12, 0x24, 0x0a, 0x0e, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x5f,
	0x6f, 0x6e, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x73,
	0x63, 0x72, 0x65, 0x65, 0x6e, 0x4f, 0x6e, 0x53, 0x65, 0x63, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x70,
	0x68, 0x6f, 0x6e, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65, 0x63,
	0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x10, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x54, 0x69,
	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x53, 0x65, 0x63, 0x73, 0x12, 0x31, 0x0a, 0x15, 0x70, 0x68, 0x6f,
	0x6e, 0x65, 0x5f, 0x73, 0x64, 0x73, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73,
	0x65, 0x63, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x53,
	0x64, 0x73, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x53, 0x65, 0x63, 0x12, 0x31, 0x0a, 0x15,
	0x6d, 0x65, 0x73, 0x68, 0x5f, 0x73, 0x64, 0x73, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74,
	0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x6d, 0x65, 0x73,
	0x68, 0x53, 0x64, 0x73, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x53, 0x65, 0x63, 0x73, 0x12,
	0x19, 0x0a, 0x08, 0x73, 0x64, 0x73, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x07, 0x73, 0x64, 0x73, 0x53, 0x65, 0x63, 0x73, 0x12, 0x17, 0x0a, 0x07, 0x6c, 0x73,
	0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6c, 0x73, 0x53,
	0x65, 0x63, 0x73, 0x12, 0x22, 0x0a, 0x0d, 0x6d, 0x69, 0x6e, 0x5f, 0x77, 0x61, 0x6b, 0x65, 0x5f,
	0x73, 0x65, 0x63, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x6d, 0x69, 0x6e, 0x57,
	0x61, 0x6b, 0x65, 0x53, 0x65, 0x63, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x77, 0x69, 0x66, 0x69, 0x5f,
	0x73, 0x73, 0x69, 0x64, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x77, 0x69, 0x66, 0x69,
	0x53, 0x73, 0x69, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x77, 0x69, 0x66, 0x69, 0x5f, 0x70, 0x61, 0x73,
	0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x77, 0x69, 0x66,
	0x69, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x20, 0x0a, 0x0c, 0x77, 0x69, 0x66,
	0x69, 0x5f, 0x61, 0x70, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0a, 0x77, 0x69, 0x66, 0x69, 0x41, 0x70, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x23, 0x0a, 0x06, 0x72,
	0x65, 0x67, 0x69, 0x6f, 0x6e, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0b, 0x2e, 0x52, 0x65,
	0x67, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x52, 0x06, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e,
	0x12, 0x35, 0x0a, 0x0e, 0x63, 0x68, 0x61, 0x72, 0x67, 0x65, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65,
	0x6e, 0x74, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0e, 0x2e, 0x43, 0x68, 0x61, 0x72, 0x67,
	0x65, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x52, 0x0d, 0x63, 0x68, 0x61, 0x72, 0x67, 0x65,
	0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x72, 0x6f,
	0x75, 0x74, 0x65, 0x72, 0x18, 0x25, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x52, 0x6f,
	0x75, 0x74, 0x65, 0x72, 0x12, 0x20, 0x0a, 0x0c, 0x69, 0x73, 0x5f, 0x6c, 0x6f, 0x77, 0x5f, 0x70,
	0x6f, 0x77, 0x65, 0x72, 0x18, 0x26, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x73, 0x4c, 0x6f,
	0x77, 0x50, 0x6f, 0x77, 0x65, 0x72, 0x12, 0x25, 0x0a, 0x0e, 0x66, 0x69, 0x78, 0x65, 0x64, 0x5f,
	0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x27, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d,
	0x66, 0x69, 0x78, 0x65, 0x64, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x0a,
	0x0d, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x74, 0x18, 0x64,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73,
	0x65, 0x74, 0x12, 0x2a, 0x0a, 0x11, 0x64, 0x65, 0x62, 0x75, 0x67, 0x5f, 0x6c, 0x6f, 0x67, 0x5f,
	0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x65, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x64,
	0x65, 0x62, 0x75, 0x67, 0x4c, 0x6f, 0x67, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x37,
	0x0a, 0x0e, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65,
	0x18, 0x20, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x53, 0x68, 0x61, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x0d, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x53, 0x68, 0x61, 0x72, 0x65, 0x12, 0x32, 0x0a, 0x0d, 0x67, 0x70, 0x73, 0x5f, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x21, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d,
	0x2e, 0x47, 0x70, 0x73, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x67,
	0x70, 0x73, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x13, 0x67,
	0x70, 0x73, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76,
	0x61, 0x6c, 0x18, 0x22, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x11, 0x67, 0x70, 0x73, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x28, 0x0a, 0x10, 0x67,
	0x70, 0x73, 0x5f, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18,
	0x24, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x67, 0x70, 0x73, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70,
	0x74, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x27, 0x0a, 0x0f, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f,
	0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x18, 0x67, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x0e,
	0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x49, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x12, 0x31,
	0x0a, 0x14, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x65,
	0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x78, 0x20, 0x01, 0x28, 0x08, 0x52, 0x13, 0x73, 0x65,
	0x72, 0x69, 0x61, 0x6c, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65,
	0x64, 0x12, 0x2b, 0x0a, 0x11, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x70, 0x6c, 0x75, 0x67, 0x69,
	0x6e, 0x5f, 0x65, 0x63, 0x68, 0x6f, 0x18, 0x79, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x73, 0x65,
	0x72, 0x69, 0x61, 0x6c, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x45, 0x63, 0x68, 0x6f, 0x12, 0x29,
	0x0a, 0x10, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x72,
	0x78, 0x64, 0x18, 0x7a, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0f, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c,
	0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x52, 0x78, 0x64, 0x12, 0x29, 0x0a, 0x10, 0x73, 0x65, 0x72,
	0x69, 0x61, 0x6c, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x74, 0x78, 0x64, 0x18, 0x7b, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0f, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x70, 0x6c, 0x75, 0x67, 0x69,
	0x6e, 0x54, 0x78, 0x64, 0x12, 0x31, 0x0a, 0x14, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x70, 0x6c,
	0x75, 0x67, 0x69, 0x6e, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x7c, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x13, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e,
	0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x2b, 0x0a, 0x11, 0x73, 0x65, 0x72, 0x69, 0x61,
	0x6c, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x7d, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x10, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e,
	0x4d, 0x6f, 0x64, 0x65, 0x12, 0x45, 0x0a, 0x1f, 0x65, 0x78, 0x74, 0x5f, 0x6e, 0x6f, 0x74, 0x69,
	0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f,
	0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x7e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1c, 0x65,
	0x78, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6c,
	0x75, 0x67, 0x69, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x48, 0x0a, 0x21, 0x65,
	0x78, 0x74, 0x5f, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x6d, 0x73,
	0x18, 0x7f, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x1d, 0x65, 0x78, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66,
	0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x4f, 0x75, 0x74,
	0x70, 0x75, 0x74, 0x4d, 0x73, 0x12, 0x44, 0x0a, 0x1e, 0x65, 0x78, 0x74, 0x5f, 0x6e, 0x6f, 0x74,
	0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e,
	0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x18, 0x80, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x1b,
	0x65, 0x78, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50,
	0x6c, 0x75, 0x67, 0x69, 0x6e, 0x4f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x12, 0x44, 0x0a, 0x1e, 0x65,
	0x78, 0x74, 0x5f, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x81, 0x01,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x1b, 0x65, 0x78, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x41, 0x63, 0x74, 0x69, 0x76,
	0x65, 0x12, 0x51, 0x0a, 0x25, 0x65, 0x78, 0x74, 0x5f, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x61, 0x6c, 0x65,
	0x72, 0x74, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x82, 0x01, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x21, 0x65, 0x78, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x41, 0x6c, 0x65, 0x72, 0x74, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x12, 0x4b, 0x0a, 0x22, 0x65, 0x78, 0x74, 0x5f, 0x6e, 0x6f, 0x74, 0x69,
	0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f,
	0x61, 0x6c, 0x65, 0x72, 0x74, 0x5f, 0x62, 0x65, 0x6c, 0x6c, 0x18, 0x83, 0x01, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x1e, 0x65, 0x78, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x41, 0x6c, 0x65, 0x72, 0x74, 0x42, 0x65, 0x6c,
	0x6c, 0x12, 0x3a, 0x0a, 0x19, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x74, 0x65, 0x73, 0x74, 0x5f,
	0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x84,
	0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x16, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x54, 0x65, 0x73, 0x74,
	0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x38, 0x0a,
	0x18, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x74, 0x65, 0x73, 0x74, 0x5f, 0x70, 0x6c, 0x75, 0x67,
	0x69, 0x6e, 0x5f, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x18, 0x85, 0x01, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x15, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x54, 0x65, 0x73, 0x74, 0x50, 0x6c, 0x75, 0x67, 0x69,
	0x6e, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x12, 0x34, 0x0a, 0x16, 0x72, 0x61, 0x6e, 0x67, 0x65,
	0x5f, 0x74, 0x65, 0x73, 0x74, 0x5f, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x73, 0x61, 0x76,
	0x65, 0x18, 0x86, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x13, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x54,
	0x65, 0x73, 0x74, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x53, 0x61, 0x76, 0x65, 0x12, 0x40, 0x0a,
	0x1c, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x5f, 0x70,
	0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x88, 0x01,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x19, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x46, 0x6f, 0x72, 0x77, 0x61,
	0x72, 0x64, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12,
	0x40, 0x0a, 0x1c, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64,
	0x5f, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x18,
	0x89, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x19, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x46, 0x6f, 0x72,
	0x77, 0x61, 0x72, 0x64, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64,
	0x73, 0x12, 0x6f, 0x0a, 0x34, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74,
	0x61, 0x6c, 0x5f, 0x6d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x70,
	0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x6d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x6d, 0x65, 0x6e,
	0x74, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x8c, 0x01, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x30, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x4d,
	0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e,
	0x4d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x61, 0x62, 0x6c,
	0x65, 0x64, 0x12, 0x65, 0x0a, 0x2f, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e,
	0x74, 0x61, 0x6c, 0x5f, 0x6d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x5f,
	0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x5f, 0x65, 0x6e,
	0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x8d, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x2b, 0x65, 0x6e,
	0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x4d, 0x65, 0x61, 0x73, 0x75,
	0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x53, 0x63, 0x72, 0x65,
	0x65, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x7b, 0x0a, 0x3b, 0x65, 0x6e, 0x76,
	0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x5f, 0x6d, 0x65, 0x61, 0x73, 0x75,
	0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x72, 0x65,
	0x61, 0x64, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x74,
	0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x8e, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x35, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x4d, 0x65,
	0x61, 0x73, 0x75, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x52,
	0x65, 0x61, 0x64, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x54, 0x68, 0x72,
	0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x12, 0x67, 0x0a, 0x30, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f,
	0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x5f, 0x6d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x6d,
	0x65, 0x6e, 0x74, 0x5f, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74,
	0x65, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x8f, 0x01, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x2c, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c,
	0x4d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x6c, 0x75, 0x67, 0x69,
	0x6e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12,
	0x6b, 0x0a, 0x32, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c,
	0x5f, 0x6d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x70, 0x6c, 0x75,
	0x67, 0x69, 0x6e, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x5f, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x90, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x2e, 0x65, 0x6e,
	0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x4d, 0x65, 0x61, 0x73, 0x75,
	0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x63, 0x6f,
	0x76, 0x65, 0x72, 0x79, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x22, 0x8b, 0x01, 0x0a,
	0x08, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x10, 0x0a, 0x03, 0x6e, 0x75, 0x6d,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x6e, 0x75, 0x6d, 0x12, 0x19, 0x0a, 0x04, 0x75,
	0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x05, 0x2e, 0x55, 0x73, 0x65, 0x72,
	0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x25, 0x0a, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x09, 0x2e, 0x50, 0x6f, 0x73, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x52, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x10, 0x0a,
	0x03, 0x73, 0x6e, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x02, 0x52, 0x03, 0x73, 0x6e, 0x72, 0x12,
	0x19, 0x0a, 0x08, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x68, 0x6f, 0x70, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x07, 0x6e, 0x65, 0x78, 0x74, 0x48, 0x6f, 0x70, 0x22, 0x97, 0x04, 0x0a, 0x0a, 0x4d,
	0x79, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1e, 0x0a, 0x0b, 0x6d, 0x79, 0x5f,
	0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09,
	0x6d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x4e, 0x75, 0x6d, 0x12, 0x17, 0x0a, 0x07, 0x68, 0x61, 0x73,
	0x5f, 0x67, 0x70, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x68, 0x61, 0x73, 0x47,
	0x70, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
	0x6c, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x6e, 0x75, 0x6d, 0x43, 0x68, 0x61,
	0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x12, 0x1a, 0x0a, 0x06, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x02, 0x18, 0x01, 0x52, 0x06, 0x72, 0x65, 0x67, 0x69, 0x6f,
	0x6e, 0x12, 0x19, 0x0a, 0x08, 0x68, 0x77, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x68, 0x77, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x29, 0x0a, 0x10,
	0x66, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x66, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65,
	0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x31, 0x0a, 0x0a, 0x65, 0x72, 0x72, 0x6f, 0x72,
	0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x43, 0x72,
	0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x52,
	0x09, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x65, 0x72,
	0x72, 0x6f, 0x72, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12,
	0x1f, 0x0a, 0x0b, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x09,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74,
	0x12, 0x24, 0x0a, 0x0e, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x5f, 0x62, 0x69,
	0x74, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,
	0x49, 0x64, 0x42, 0x69, 0x74, 0x73, 0x12, 0x2e, 0x0a, 0x11, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
	0x74, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28,
	0x0d, 0x42, 0x02, 0x18, 0x01, 0x52, 0x0f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x50, 0x61,
	0x63, 0x6b, 0x65, 0x74, 0x49, 0x64, 0x12, 0x22, 0x0a, 0x0d, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6e,
	0x75, 0x6d, 0x5f, 0x62, 0x69, 0x74, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x6e,
	0x6f, 0x64, 0x65, 0x4e, 0x75, 0x6d, 0x42, 0x69, 0x74, 0x73, 0x12, 0x30, 0x0a, 0x14, 0x6d, 0x65,
	0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x6d, 0x73,
	0x65, 0x63, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x4d, 0x73, 0x65, 0x63, 0x12, 0x26, 0x0a, 0x0f,
	0x6d, 0x69, 0x6e, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,
	0x0e, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x6d, 0x69, 0x6e, 0x41, 0x70, 0x70, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x22, 0xd3, 0x01, 0x0a, 0x09, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f,
	0x72, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x12, 0x0a, 0x04,
	0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65,
	0x12, 0x16, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x26, 0x0a, 0x05, 0x6c, 0x65, 0x76, 0x65,
	0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63,
	0x6f, 0x72, 0x64, 0x2e, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c,
	0x22, 0x58, 0x0a, 0x05, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x09, 0x0a, 0x05, 0x55, 0x4e, 0x53,
	0x45, 0x54, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x43, 0x52, 0x49, 0x54, 0x49, 0x43, 0x41, 0x4c,
	0x10, 0x32, 0x12, 0x09, 0x0a, 0x05, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x28, 0x12, 0x0b, 0x0a,
	0x07, 0x57, 0x41, 0x52, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x1e, 0x12, 0x08, 0x0a, 0x04, 0x49, 0x4e,
	0x46, 0x4f, 0x10, 0x14, 0x12, 0x09, 0x0a, 0x05, 0x44, 0x45, 0x42, 0x55, 0x47, 0x10, 0x0a, 0x12,
	0x09, 0x0a, 0x05, 0x54, 0x52, 0x41, 0x43, 0x45, 0x10, 0x05, 0x22, 0xf7, 0x02, 0x0a, 0x09, 0x46,
	0x72, 0x6f, 0x6d, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x12, 0x10, 0x0a, 0x03, 0x6e, 0x75, 0x6d, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x6e, 0x75, 0x6d, 0x12, 0x25, 0x0a, 0x06, 0x70, 0x61,
	0x63, 0x6b, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x4d, 0x65, 0x73,
	0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x48, 0x00, 0x52, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65,
	0x74, 0x12, 0x26, 0x0a, 0x07, 0x6d, 0x79, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x4d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x48,
	0x00, 0x52, 0x06, 0x6d, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x28, 0x0a, 0x09, 0x6e, 0x6f, 0x64,
	0x65, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x09, 0x2e, 0x4e,
	0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52, 0x08, 0x6e, 0x6f, 0x64, 0x65, 0x49,
	0x6e, 0x66, 0x6f, 0x12, 0x24, 0x0a, 0x05, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x48, 0x00, 0x52, 0x05, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x12, 0x2b, 0x0a, 0x0a, 0x6c, 0x6f, 0x67,
	0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e,
	0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x48, 0x00, 0x52, 0x09, 0x6c, 0x6f, 0x67,
	0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x2e, 0x0a, 0x12, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x0d, 0x48, 0x00, 0x52, 0x10, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x43, 0x6f, 0x6d, 0x70,
	0x6c, 0x65, 0x74, 0x65, 0x49, 0x64, 0x12, 0x1c, 0x0a, 0x08, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74,
	0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x08, 0x72, 0x65, 0x62, 0x6f,
	0x6f, 0x74, 0x65, 0x64, 0x12, 0x2c, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18,
	0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53,
	0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x48, 0x00, 0x52, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e,
	0x65, 0x6c, 0x42, 0x10, 0x0a, 0x0e, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x56, 0x61, 0x72,
	0x69, 0x61, 0x6e, 0x74, 0x22, 0xf2, 0x01, 0x0a, 0x07, 0x54, 0x6f, 0x52, 0x61, 0x64, 0x69, 0x6f,
	0x12, 0x25, 0x0a, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x0b, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x48, 0x00, 0x52,
	0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x26, 0x0a, 0x0e, 0x77, 0x61, 0x6e, 0x74, 0x5f,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x69, 0x64, 0x18, 0x64, 0x20, 0x01, 0x28, 0x0d, 0x48,
	0x00, 0x52, 0x0c, 0x77, 0x61, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x49, 0x64, 0x12,
	0x2b, 0x0a, 0x09, 0x73, 0x65, 0x74, 0x5f, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x18, 0x65, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x48, 0x00, 0x52, 0x08, 0x73, 0x65, 0x74, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x12, 0x24, 0x0a, 0x09,
	0x73, 0x65, 0x74, 0x5f, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x66, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x05, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x48, 0x00, 0x52, 0x08, 0x73, 0x65, 0x74, 0x4f, 0x77, 0x6e,
	0x65, 0x72, 0x12, 0x33, 0x0a, 0x0b, 0x73, 0x65, 0x74, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
	0x6c, 0x18, 0x67, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65,
	0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x48, 0x00, 0x52, 0x0a, 0x73, 0x65, 0x74,
	0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x42, 0x10, 0x0a, 0x0e, 0x70, 0x61, 0x79, 0x6c, 0x6f,
	0x61, 0x64, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x2a, 0x65, 0x0a, 0x0b, 0x45, 0x72, 0x72,
	0x6f, 0x72, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45,
	0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x4e, 0x4f, 0x5f, 0x52, 0x4f, 0x55, 0x54, 0x45, 0x10, 0x01,
	0x12, 0x0b, 0x0a, 0x07, 0x47, 0x4f, 0x54, 0x5f, 0x4e, 0x41, 0x4b, 0x10, 0x02, 0x12, 0x0b, 0x0a,
	0x07, 0x54, 0x49, 0x4d, 0x45, 0x4f, 0x55, 0x54, 0x10, 0x03, 0x12, 0x10, 0x0a, 0x0c, 0x4e, 0x4f,
	0x5f, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x46, 0x41, 0x43, 0x45, 0x10, 0x04, 0x12, 0x12, 0x0a, 0x0e,
	0x4d, 0x41, 0x58, 0x5f, 0x52, 0x45, 0x54, 0x52, 0x41, 0x4e, 0x53, 0x4d, 0x49, 0x54, 0x10, 0x05,
	0x2a, 0x2e, 0x0a, 0x09, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x73, 0x12, 0x0a, 0x0a,
	0x06, 0x55, 0x6e, 0x75, 0x73, 0x65, 0x64, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x10, 0x44, 0x41, 0x54,
	0x41, 0x5f, 0x50, 0x41, 0x59, 0x4c, 0x4f, 0x41, 0x44, 0x5f, 0x4c, 0x45, 0x4e, 0x10, 0xf0, 0x01,
	0x2a, 0x5e, 0x0a, 0x0a, 0x52, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x09,
	0x0a, 0x05, 0x55, 0x6e, 0x73, 0x65, 0x74, 0x10, 0x00, 0x12, 0x06, 0x0a, 0x02, 0x55, 0x53, 0x10,
	0x01, 0x12, 0x09, 0x0a, 0x05, 0x45, 0x55, 0x34, 0x33, 0x33, 0x10, 0x02, 0x12, 0x09, 0x0a, 0x05,
	0x45, 0x55, 0x38, 0x36, 0x35, 0x10, 0x03, 0x12, 0x06, 0x0a, 0x02, 0x43, 0x4e, 0x10, 0x04, 0x12,
	0x06, 0x0a, 0x02, 0x4a, 0x50, 0x10, 0x05, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x4e, 0x5a, 0x10, 0x06,
	0x12, 0x06, 0x0a, 0x02, 0x4b, 0x52, 0x10, 0x07, 0x12, 0x06, 0x0a, 0x02, 0x54, 0x57, 0x10, 0x08,
	0x2a, 0xd1, 0x01, 0x0a, 0x0d, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65, 0x43, 0x75, 0x72, 0x72, 0x65,
	0x6e, 0x74, 0x12, 0x0b, 0x0a, 0x07, 0x4d, 0x41, 0x55, 0x6e, 0x73, 0x65, 0x74, 0x10, 0x00, 0x12,
	0x09, 0x0a, 0x05, 0x4d, 0x41, 0x31, 0x30, 0x30, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05, 0x4d, 0x41,
	0x31, 0x39, 0x30, 0x10, 0x02, 0x12, 0x09, 0x0a, 0x05, 0x4d, 0x41, 0x32, 0x38, 0x30, 0x10, 0x03,
	0x12, 0x09, 0x0a, 0x05, 0x4d, 0x41, 0x33, 0x36, 0x30, 0x10, 0x04, 0x12, 0x09, 0x0a, 0x05, 0x4d,
	0x41, 0x34, 0x35, 0x30, 0x10, 0x05, 0x12, 0x09, 0x0a, 0x05, 0x4d, 0x41, 0x35, 0x35, 0x30, 0x10,
	0x06, 0x12, 0x09, 0x0a, 0x05, 0x4d, 0x41, 0x36, 0x33, 0x30, 0x10, 0x07, 0x12, 0x09, 0x0a, 0x05,
	0x4d, 0x41, 0x37, 0x30, 0x30, 0x10, 0x08, 0x12, 0x09, 0x0a, 0x05, 0x4d, 0x41, 0x37, 0x38, 0x30,
	0x10, 0x09, 0x12, 0x09, 0x0a, 0x05, 0x4d, 0x41, 0x38, 0x38, 0x30, 0x10, 0x0a, 0x12, 0x09, 0x0a,
	0x05, 0x4d, 0x41, 0x39, 0x36, 0x30, 0x10, 0x0b, 0x12, 0x0a, 0x0a, 0x06, 0x4d, 0x41, 0x31, 0x30,
	0x30, 0x30, 0x10, 0x0c, 0x12, 0x0a, 0x0a, 0x06, 0x4d, 0x41, 0x31, 0x30, 0x38, 0x30, 0x10, 0x0d,
	0x12, 0x0a, 0x0a, 0x06, 0x4d, 0x41, 0x31, 0x31, 0x36, 0x30, 0x10, 0x0e, 0x12, 0x0a, 0x0a, 0x06,
	0x4d, 0x41, 0x31, 0x32, 0x34, 0x30, 0x10, 0x0f, 0x12, 0x0a, 0x0a, 0x06, 0x4d, 0x41, 0x31, 0x33,
	0x32, 0x30, 0x10, 0x10, 0x2a, 0x6a, 0x0a, 0x0c, 0x47, 0x70, 0x73, 0x4f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x0a, 0x47, 0x70, 0x73, 0x4f, 0x70, 0x55, 0x6e, 0x73,
	0x65, 0x74, 0x10, 0x00, 0x12, 0x13, 0x0a, 0x0f, 0x47, 0x70, 0x73, 0x4f, 0x70, 0x53, 0x74, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x61, 0x72, 0x79, 0x10, 0x01, 0x12, 0x0f, 0x0a, 0x0b, 0x47, 0x70, 0x73,
	0x4f, 0x70, 0x4d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x10, 0x02, 0x12, 0x11, 0x0a, 0x0d, 0x47, 0x70,
	0x73, 0x4f, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x4f, 0x6e, 0x6c, 0x79, 0x10, 0x03, 0x12, 0x11, 0x0a,
	0x0d, 0x47, 0x70, 0x73, 0x4f, 0x70, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x10, 0x04,
	0x2a, 0x40, 0x0a, 0x0f, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x68, 0x61, 0x72,
	0x69, 0x6e, 0x67, 0x12, 0x0c, 0x0a, 0x08, 0x4c, 0x6f, 0x63, 0x55, 0x6e, 0x73, 0x65, 0x74, 0x10,
	0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x4c, 0x6f, 0x63, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x10,
	0x01, 0x12, 0x0f, 0x0a, 0x0b, 0x4c, 0x6f, 0x63, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64,
	0x10, 0x02, 0x2a, 0xaf, 0x01, 0x0a, 0x11, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x45,
	0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x6f, 0x6e, 0x65,
	0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x54, 0x78, 0x57, 0x61, 0x74, 0x63, 0x68, 0x64, 0x6f, 0x67,
	0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e, 0x53, 0x6c, 0x65, 0x65, 0x70, 0x45, 0x6e, 0x74, 0x65, 0x72,
	0x57, 0x61, 0x69, 0x74, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x4e, 0x6f, 0x52, 0x61, 0x64, 0x69,
	0x6f, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x6e, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69,
	0x65, 0x64, 0x10, 0x04, 0x12, 0x13, 0x0a, 0x0f, 0x55, 0x42, 0x6c, 0x6f, 0x78, 0x49, 0x6e, 0x69,
	0x74, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x10, 0x05, 0x12, 0x0c, 0x0a, 0x08, 0x4e, 0x6f, 0x41,
	0x58, 0x50, 0x31, 0x39, 0x32, 0x10, 0x06, 0x12, 0x17, 0x0a, 0x13, 0x49, 0x6e, 0x76, 0x61, 0x6c,
	0x69, 0x64, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x10, 0x07,
	0x12, 0x12, 0x0a, 0x0e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x6d, 0x69, 0x74, 0x46, 0x61, 0x69, 0x6c,
	0x65, 0x64, 0x10, 0x08, 0x42, 0x45, 0x0a, 0x13, 0x63, 0x6f, 0x6d, 0x2e, 0x67, 0x65, 0x65, 0x6b,
	0x73, 0x76, 0x69, 0x6c, 0x6c, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x42, 0x0a, 0x4d, 0x65, 0x73,
	0x68, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x48, 0x03, 0x5a, 0x20, 0x67, 0x69, 0x74, 0x68, 0x75,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6c, 0x6d, 0x61, 0x74, 0x74, 0x65, 0x37, 0x2f, 0x6d, 0x65,
	0x73, 0x68, 0x74, 0x61, 0x73, 0x74, 0x69, 0x63, 0x2d, 0x67, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x33,
}

var (
	file_mesh_proto_rawDescOnce sync.Once
	file_mesh_proto_rawDescData = file_mesh_proto_rawDesc
)

func file_mesh_proto_rawDescGZIP() []byte {
	file_mesh_proto_rawDescOnce.Do(func() {
		file_mesh_proto_rawDescData = protoimpl.X.CompressGZIP(file_mesh_proto_rawDescData)
	})
	return file_mesh_proto_rawDescData
}

var file_mesh_proto_enumTypes = make([]protoimpl.EnumInfo, 10)
var file_mesh_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_mesh_proto_goTypes = []interface{}{
	(ErrorReason)(0),                    // 0: ErrorReason
	(Constants)(0),                      // 1: Constants
	(RegionCode)(0),                     // 2: RegionCode
	(ChargeCurrent)(0),                  // 3: ChargeCurrent
	(GpsOperation)(0),                   // 4: GpsOperation
	(LocationSharing)(0),                // 5: LocationSharing
	(CriticalErrorCode)(0),              // 6: CriticalErrorCode
	(MeshPacket_Priority)(0),            // 7: MeshPacket.Priority
	(ChannelSettings_ModemConfig)(0),    // 8: ChannelSettings.ModemConfig
	(LogRecord_Level)(0),                // 9: LogRecord.Level
	(*Position)(nil),                    // 10: Position
	(*Data)(nil),                        // 11: Data
	(*User)(nil),                        // 12: User
	(*RouteDiscovery)(nil),              // 13: RouteDiscovery
	(*SubPacket)(nil),                   // 14: SubPacket
	(*MeshPacket)(nil),                  // 15: MeshPacket
	(*ChannelSettings)(nil),             // 16: ChannelSettings
	(*RadioConfig)(nil),                 // 17: RadioConfig
	(*NodeInfo)(nil),                    // 18: NodeInfo
	(*MyNodeInfo)(nil),                  // 19: MyNodeInfo
	(*LogRecord)(nil),                   // 20: LogRecord
	(*FromRadio)(nil),                   // 21: FromRadio
	(*ToRadio)(nil),                     // 22: ToRadio
	(*RadioConfig_UserPreferences)(nil), // 23: RadioConfig.UserPreferences
	(PortNum)(0),                        // 24: PortNum
}
var file_mesh_proto_depIdxs = []int32{
	24, // 0: Data.portnum:type_name -> PortNum
	11, // 1: SubPacket.data:type_name -> Data
	13, // 2: SubPacket.route_request:type_name -> RouteDiscovery
	13, // 3: SubPacket.route_reply:type_name -> RouteDiscovery
	0,  // 4: SubPacket.error_reason:type_name -> ErrorReason
	10, // 5: SubPacket.position:type_name -> Position
	12, // 6: SubPacket.user:type_name -> User
	14, // 7: MeshPacket.decoded:type_name -> SubPacket
	7,  // 8: MeshPacket.priority:type_name -> MeshPacket.Priority
	8,  // 9: ChannelSettings.modem_config:type_name -> ChannelSettings.ModemConfig
	23, // 10: RadioConfig.preferences:type_name -> RadioConfig.UserPreferences
	16, // 11: RadioConfig.channel_settings:type_name -> ChannelSettings
	12, // 12: NodeInfo.user:type_name -> User
	10, // 13: NodeInfo.position:type_name -> Position
	6,  // 14: MyNodeInfo.error_code:type_name -> CriticalErrorCode
	9,  // 15: LogRecord.level:type_name -> LogRecord.Level
	15, // 16: FromRadio.packet:type_name -> MeshPacket
	19, // 17: FromRadio.my_info:type_name -> MyNodeInfo
	18, // 18: FromRadio.node_info:type_name -> NodeInfo
	17, // 19: FromRadio.radio:type_name -> RadioConfig
	20, // 20: FromRadio.log_record:type_name -> LogRecord
	16, // 21: FromRadio.channel:type_name -> ChannelSettings
	15, // 22: ToRadio.packet:type_name -> MeshPacket
	17, // 23: ToRadio.set_radio:type_name -> RadioConfig
	12, // 24: ToRadio.set_owner:type_name -> User
	16, // 25: ToRadio.set_channel:type_name -> ChannelSettings
	2,  // 26: RadioConfig.UserPreferences.region:type_name -> RegionCode
	3,  // 27: RadioConfig.UserPreferences.charge_current:type_name -> ChargeCurrent
	5,  // 28: RadioConfig.UserPreferences.location_share:type_name -> LocationSharing
	4,  // 29: RadioConfig.UserPreferences.gps_operation:type_name -> GpsOperation
	30, // [30:30] is the sub-list for method output_type
	30, // [30:30] is the sub-list for method input_type
	30, // [30:30] is the sub-list for extension type_name
	30, // [30:30] is the sub-list for extension extendee
	0,  // [0:30] is the sub-list for field type_name
}

func init() { file_mesh_proto_init() }
func file_mesh_proto_init() {
	if File_mesh_proto != nil {
		return
	}
	file_portnums_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_mesh_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Position); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Data); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*User); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteDiscovery); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SubPacket); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MeshPacket); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ChannelSettings); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RadioConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MyNodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LogRecord); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FromRadio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ToRadio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RadioConfig_UserPreferences); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_mesh_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*SubPacket_Data)(nil),
		(*SubPacket_RouteRequest)(nil),
		(*SubPacket_RouteReply)(nil),
		(*SubPacket_ErrorReason)(nil),
		(*SubPacket_Position)(nil),
		(*SubPacket_User)(nil),
		(*SubPacket_SuccessId)(nil),
		(*SubPacket_FailId)(nil),
	}
	file_mesh_proto_msgTypes[5].OneofWrappers = []interface{}{
		(*MeshPacket_Decoded)(nil),
		(*MeshPacket_Encrypted)(nil),
	}
	file_mesh_proto_msgTypes[11].OneofWrappers = []interface{}{
		(*FromRadio_Packet)(nil),
		(*FromRadio_MyInfo)(nil),
		(*FromRadio_NodeInfo)(nil),
		(*FromRadio_Radio)(nil),
		(*FromRadio_LogRecord)(nil),
		(*FromRadio_ConfigCompleteId)(nil),
		(*FromRadio_Rebooted)(nil),
		(*FromRadio_Channel)(nil),
	}
	file_mesh_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*ToRadio_Packet)(nil),
		(*ToRadio_WantConfigId)(nil),
		(*ToRadio_SetRadio)(nil),
		(*ToRadio_SetOwner)(nil),
		(*ToRadio_SetChannel)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_mesh_proto_rawDesc,
			NumEnums:      10,
			NumMessages:   14,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_mesh_proto_goTypes,
		DependencyIndexes: file_mesh_proto_depIdxs,
		EnumInfos:         file_mesh_proto_enumTypes,
		MessageInfos:      file_mesh_proto_msgTypes,
	}.Build()
	File_mesh_proto = out.File
	file_mesh_proto_rawDesc = nil
	file_mesh_proto_goTypes = nil
	file_mesh_proto_depIdxs = nil
}
